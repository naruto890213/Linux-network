|-->äº¤æ¢é«˜é€Ÿç¼“å­?	|-->lookup_swap_cache //(swap_state.c) 
		|-->

	|-->add_to_swap_cache //(swap_state.c) æŠŠé¡µæ’å…¥äº¤æ¢é«˜é€Ÿç¼“å­˜ä¸­ è§ä¸‹é¢çš„æµç¨‹åˆ†æž
		|-->

	|-->__add_to_swap_cache //(swap_state.c) 

	|-->delete_from_swap_cache //(swap_state.c)

	|-->

|-->æ¢å…¥é¡?	|-->do_swap_page //(memory.c)
		|-->pte_unmap_same //()
		|-->pte_to_swp_entry //()
		|-->lookup_swap_cache //()
		|-->ksm_might_need_to_copy //()
		|-->mem_cgroup_try_charge //()
		|-->mk_pte //()
		|-->flush_icache_page //()
		|-->pte_swp_soft_dirty //()
		|-->pte_mksoft_dirty //()
		|-->activate_page //()
		|-->lru_cache_add_active_or_unevictable //()
		|-->swap_free //()
		|-->update_mmu_cache //()


|-->do_anonymous_page //(memory.c) åŠ è½½åŒ¿åé¡?
|-->mark_page_accessed //(swap.c) å¤„ç†é¡µæ ‡è®°ï¼Œå°†å…¶æ ‡è®°ä¸ºè®¿é—®è¿‡çš„é¡µé?
|-->try_to_unuse //(swapfile.c)
	|-->start_mm = &init_mm; //(init-mm.c)
	|-->mmget //(mm.h)
	|-->read_swap_cache_async //(swap_state.c)
		|-->__read_swap_cache_async //(swap_state.c)
			|-->find_get_page //()
			|-->alloc_page_vma //()
			|-->radix_tree_maybe_preload //()
			|-->swapcache_prepare //()
			|-->__add_to_swap_cache //()
			|-->radix_tree_preload_end //()
			|-->lru_cache_add_anon //()


|-->SYSCALL_DEFINE2(swapon, const char __user *, specialfile, int, swap_flags) //(swapfile.c) å¯¹åˆ›å»ºäº¤æ¢åŒºæ—¶æ”¾å…¥ç¬¬ä¸€ä¸ªé¡µæ§½ä¸­çš„swap_headerè”åˆä½“å­—æ®µè¿›è¡Œæ£€æŸ?	|-->alloc_swap_info //(swapfile.c) åˆ†é…ä¸€ä¸ªå†…å­˜ï¼Œå¹¶è¿›è¡Œåˆå§‹åŒ–
	|-->INIT_WORK(&p->discard_work, swap_discard_work) //(swapfile.c) å°†discard_workè¿›è¡Œèµ‹å€?	|-->file_open_name //(open.c)
	|-->claim_swapfile //(swapfile.c)
	|-->read_mapping_page //()
	|-->read_swap_header //(swapfile.c)
		|-->if (memcmp("SWAPSPACE2", swap_header->magic.magic, 10)) //(swapfile.c) åˆ¤æ–­magicæ˜¯å¦ä¸ºSWAPSPACE2
			|-->return 0;

		|-->p->lowest_bit  = 1 //
		|-->p->highest_bit = maxpages - 1; //

	|-->vzalloc //(nommu.c) åˆ›å»ºä¸Žæ–°äº¤æ¢åŒºç›¸å…³çš„è®¡æ•°å™¨æ•°ç»„ï¼Œå¹¶æŠŠå®ƒçš„åœ°å€å­˜æ”¾åœ¨äº¤æ¢æè¿°ç¬¦çš„swap_mapå­—æ®µä¸­ï¼Œè¿˜è¦æ ¹æ®swap_headerè”åˆä½“çš„info.bad_pageså­—æ®µä¸­å­˜æ”¾çš„æœ‰ç¼ºé™·çš„é¡µæ§½é“¾è¡¨æŠŠè¿™ä¸ªæ•°ç»„çš„å…ƒç´ åˆå§‹åŒ–ä¸º0æˆ–è€…SWAP_MAP_BAD
		|-->__vmalloc //(nommu.c)
			|-->kmalloc //(slab.h)
				|-->__kmalloc //(slab.c)
					|-->__do_kmalloc //(slab.c)
						|-->kmalloc_slab //()
						|-->slab_alloc //()
						|-->kasan_kmalloc //()


|-->kswapd çº¿ç¨‹ï¼Œç”¨äºŽå®šæœŸç»´æŠ¤å›žæ”¶é¡µæ¡?|-->kswapd_run //(vmscan.c)
	|-->pgdat->kswapd = kthread_run(kswapd, pgdat, "kswapd%d", nid) //(vmscan.c)
		|-->kswapd //(vmscan.c)
			|-->try_to_freeze //(freezer.h)
				|-->try_to_freeze_unsafe //(freezer.h)
					|-->freezing //(freezer.h)
						|-->freezing_slow_path //(freezer.c)
							|-->

			|-->balance_pgdat //(vmscan.c)
				|-->kswapd_shrink_node //(vmscan.c)
					|-->shrink_node //(vmscan.c)

|-->cache_reapé«˜é€Ÿç¼“å­˜å›žæ”¶é¡µæ¡?å†…æ ¸çš?ç§æ–¹å¼ä¹‹ä¸€ï¼Œå¦ä¸€ç§æ˜¯kswapdå†…æ ¸çº¿ç¨‹
|-->start_cpu_timer //(slab.c)
	|-->INIT_DEFERRABLE_WORK(reap_work, cache_reap)//(slab.c)
		|-->cache_reap //(slab.c)
			|-->drain_freelist //(slab.c)
				|-->list_entry(p, struct page, lru) //(slab.c)
				|-->list_del(&page->lru) //(slab.c)
				|-->slab_destroy //(slab.c)
					|-->kmem_freepages //(slab.c)
						|-->__free_pages //(page_alloc.c)
							|-->free_hot_cold_page //()
							|-->__free_pages_ok //(page_alloc.c)
								|-->free_one_page //(age_alloc.c)
									|-->__free_one_page //(page_alloc.c)
										|-->

					|-->kmem_cache_free //()

|-->work_struct //(include/linux/workqueue.h)
|-->typedef void (*work_func_t)(struct work_struct *work); //(include/linux/workqueue.h)
struct work_struct {
    atomic_long_t data;
    struct list_head entry;
    work_func_t func;
#ifdef CONFIG_LOCKDEP
    struct lockdep_map lockdep_map;
#endif
};

|-->delayed_work //(include/linux/workqueue.h)
struct delayed_work {
    struct work_struct work;
    struct timer_list timer;

    /* target workqueue and CPU ->timer uses to queue ->work */
    struct workqueue_struct *wq;
    int cpu;
};

|-->out_of_memory //(oom_kill.c)
	|-->select_bad_process //(oom_kill.c)
	|-->oom_kill_process //(oom_kill.c)

|-->page_referenced //(rmap.c)
	|-->.rmap_one = page_referenced_one //(rmap.c)
	|-->rwc.invalid_vma = invalid_page_referenced_vma //(rmap.c)
	|-->rmap_walk //(rmap.c) 3ä¸ªåˆ†æ”¯ï¼Œåˆ†åˆ«æ˜¯å†…æ ¸ã€åŒ¿åæ˜ å°„ã€æ–‡ä»¶æ˜ å°?		|-->rmap_walk_ksm //()
		|-->rmap_walk_anon //(rmap.c)
		|-->rmap_walk_file //(rmap.c)
			|-->rwc->invalid_vma && rwc->invalid_vma(vma, rwc->arg) //()
				|-->invalid_page_referenced_vma //(rmap.c)
					|-->mm_match_cgroup //(memcontrol.h)
						|-->mem_cgroup_from_task //()
						|-->mem_cgroup_is_descendant //()

			|-->rwc->rmap_one(page, vma, address, rwc->arg) //()
				|-->page_referenced_one //(rmap.c)
					|-->page_vma_mapped_walk //()
					|-->

|-->vma ç®¡ç† //(include/linux/mm_types.h)
struct vm_area_struct {
	unsigned long vm_start;//å½“å‰è¿™ä¸ªVMAçš„èµ·å§‹è™šæ‹Ÿåœ°å€
	unsigned long vm_end; //vm_endæ˜¯ç»“æŸåœ°å€åŽçš„ä¸€ä¸ªbyteçš„åœ°å€
	struct vm_area_struct *vm_next, *vm_prev; //å½“å‰è¿›ç¨‹çš„æ‰€æœ‰çš„VMAé“¾æŽ¥èµ·æ¥
	pgprot_t vm_page_prot; //è®¿é—®æƒé™
};__randomize_layout;


|-->zoneæ•°æ®ç»“æž„ //(include/linux/mmzone.h)
struct zone {
	unsigned long watermark[NR_WMARK]; //å†…å­˜æ°´ä½WMARK_MINã€WMARK_LOWã€WMARK_HIGH
	long lowmem_reserve[MAX_NR_ZONES] //æ¯ä¸ªç®¡ç†åŒºå¿…é¡»ä¿ç•™çš„é¡µæ¡†æ•
	struct pglist_data  *zone_pgdat; //zoneçš„ä¸»è¦æ•°æ®ç»“æž„ï¼Œå†…éƒ¨åŒ…å«lrué“¾è¡¨å’Œå…·ä½“çš„æ•°æ®
	unsigned long       spanned_pages; //ç®¡ç†åŒºçš„å¤§å°,åŒ…æ‹¬æ´
	unsigned long       present_pages; //ç®¡ç†åŒºçš„å¤§å°ï¼Œä¸åŒ…æ‹¬æ´
	.......
};

|-->lruæ•°æ®ç»“æž„ä½?//(include/linux/mmzone.h)
	|-->NR_LRU_LISTS //(mmzone.h) å†…éƒ¨åŒ…å«5æ¡list
		|-->LRU_INACTIVE_ANON // ä¸æ´»è·ƒçš„åŒ¿åé¡? page->flagsä¸å¸¦æœ‰PG_active
		|-->LRU_ACTIVE_ANON // æ´»è·ƒçš„åŒ¿åé¡µ page->flagså¸¦æœ‰PG_active
		|-->LRU_INACTIVE_FILE // ä¸æ´»è·ƒçš„æ–‡ä»¶ç¼“å­˜ page->flagsä¸å¸¦æœ‰PG_active 
		|-->LRU_ACTIVE_FILE // æ´»è·ƒçš„æ–‡ä»¶ç¼“å­?page->flagså¸¦æœ‰PG_active
		|-->LRU_UNEVICTABLE // ä¸å¯å›žæ”¶é¡?page->flagså¸¦æœ‰PG_unevictable
		
struct lruvec {
    struct list_head        lists[NR_LRU_LISTS];//å†…éƒ¨åŒ…å«5æ¡é“¾è¡¨ï¼Œåˆ†åˆ«æ˜¯LRU_INACTIVE_ANON
    struct zone_reclaim_stat    reclaim_stat;
    /* Evictions & activations on the inactive file list */
    atomic_long_t           inactive_age;
    /* Refaults at the time of last reclaim cycle */
    unsigned long           refaults;
#ifdef CONFIG_MEMCG
    struct pglist_data *pgdat;
#endif
};

|-->äº¤æ¢åŒºçš„æ•°æ®ç»“æž„ //(swap.h)
|-->æ¯ä¸ªäº¤æ¢åŒºéƒ½ç”±ä¸€ç»„é¡µæ§½ï¼ˆpage slotï¼‰ç»„æˆï¼Œæ¯ä¸ªé¡µæ§½å¤§å°ä¸€é¡µã€‚äº¤æ¢åŒºçš„ç¬¬ä¸€ä¸ªé¡µæ§½æ°¸ä¹…å­˜æ”¾æœ‰å…³äº¤æ¢åŒºçš„ä¿¡æ
union swap_header {
	struct {
        char reserved[PAGE_SIZE - 10];
        char magic[10];         /* SWAP-SPACE or SWAPSPACE2  ç”¨äºŽæ ‡è®°åˆ†åŒºæˆ–æ–‡ä»¶ä¸ºäº¤æ¢åŒ?/
    } magic;
    struct {
        char        bootbits[1024]; /* Space for disklabel etc. åŒ…å«åˆ†åŒºæ•°æ®ã€ç£ç›˜æ ‡ç­¾ç­‰*/
        __u32       version; //äº¤æ¢ç®—æ³•çš„ç‰ˆæœ
        __u32       last_page; //å¯æœ‰æ•ˆä½¿ç”¨çš„æœ€åŽä¸€ä¸ªæ§½
        __u32       nr_badpages; //æœ‰ç¼ºé™·çš„é¡µæ§½çš„ä¸ªæ•
        unsigned char   sws_uuid[16];
        unsigned char   sws_volume[16];
        __u32       padding[117]; //ç”¨äºŽå¡«å……çš„å­—èŠ
        __u32       badpages[1]; //ç”¨æ¥æŒ‡å®šæœ‰ç¼ºé™·çš„é¡µæ§½çš„ä½ç½
    } info;
};



|-->mmap_mem //(drivers/char/mem.c) mmapçš„å®žçŽ
	|-->remap_pfn_range //(memory.c)
		|-->pgd_addr_end //(memory.c)
		|-->remap_p4d_range //(memory.c)
			|-->p4d_alloc //(memory.c)
			|-->p4d_addr_end //(memory.c)
			|-->remap_pud_range //(memory.c)	
				|-->pud_alloc //(memory.c)
				|-->pud_addr_end //(memory.c)
				|-->remap_pmd_range //(memory.c)
					|-->pmd_alloc //(memory.c)
					|-->pmd_addr_end //(memory.c)
					|-->remap_pte_range //(memory.c)
						|-->pte_alloc_map_lock //(mm.h)
							|-->pte_alloc //(mm.h)
								|-->__pte_alloc //(memory.c)
									|-->pte_alloc_one //(pgtable.c)
										|-->alloc_pages //(gfp.h)
											|-->alloc_pages_current //(mempolicy.c)
												|-->alloc_page_interleave //() é€‚ç”¨äºŽå¤§å†…å­˜åˆ†é…ï¼Œç„¶åŽå°†å…¶æ¸…é›?				
												|-->__alloc_pages_nodemask //(page_alloc.c)
													|-->prepare_alloc_pages //(page_alloc.c)
														|-->gfp_zone //(gfp.h) æ ¹æ®å‚æ•°gfp_maskæ‰¾åˆ°é€‚åˆçš„åŒºåŸ?åŒºåŸŸåŒ…æ‹¬ZONE_DMAã€ZONE_DMA32ã€ZONE_NORMALã€ZONE_HIGHMEM)
														|-->node_zonelist //(gfp.h)
														|-->gfpflags_to_migratetype //(gfp.h) æ ¹æ®é¡µé¢ç”³è¯·æ ‡å¿—gfp_maskè½¬æ¢ä¸ºç›¸åº”çš„å†…å­˜è¿ç§»ç±»åž‹
														
														|-->should_fail_alloc_page //(page_alloc.c)
															|-->should_fail //(fault-inject.c)
																|-->in_task //()
															
													|-->get_page_from_freelist //(page_alloc.c)
														|-->for_next_zone_zonelist_nodemask //(mmzone.h) å¾ªçŽ¯zoneé“¾è¡¨
														|-->node_dirty_ok //(page-writeback.c) æŸ¥çœ‹æ˜¯å¦dirtyçš„æ•°é‡æ˜¯å¦å·²ç»åˆ°limit
														|-->zone_watermark_fast //(page_alloc.c)
															|-->__zone_watermark_ok //(page_alloc.c)
																|-->list_empty(&area->free_list) //(page_alloc.c) æ£€æŸ¥free_listé“¾è¡¨æ˜¯å¦è¿˜æœ‰èŠ‚ç‚¹ ç”¨äºŽå¿«é€Ÿåˆ†é…?														
														|-->zone_allows_reclaim //()
														|-->node_reclaim //()
														|-->zone_watermark_ok //()
														|-->rmqueue //(page_alloc.c)
															|-->rmqueue_pcplist //(page_alloc.c)
																|-->__rmqueue_pcplist //(page_alloc.c)
																	|-->rmqueue_bulk //(page_alloc.c)
																		|-->__rmqueue //(page_alloc.c)
																			|-->__rmqueue_smallest //(page_alloc.c)
																				|-->list_first_entry_or_null //()
																			
																			|-->trace_mm_page_alloc_zone_locked //()
																		
																		|-->check_pcp_refill //(page_alloc.c)
																			|-->check_new_page //(page_alloc.c)
																				|-->return 0;
																		
																		|-->list_add(&page->lru, list) //()
																		|-->list_add_tail(&page->lru, list) //()
																		|-->__mod_zone_page_state //(vmstat.h)
																			|-->zone_page_state_add //(vmstat.h)
																	
																	if(cold)
																		|-->list_last_entry //(list.h) èŽ·å–lrué“¾è¡¨çš„å°¾éƒ¨å…ƒç´
																	else
																		|-->list_first_entry //(list.h) æ’å…¥lrué“¾è¡¨çš„å¤´éƒ¨å…ƒç´
																		
																	|-->list_del(&page->lru) //å°†pageä»Žlrué“¾è¡¨ä¸­åˆ é™
																	|-->check_new_pcp //(page_alloc.c)
																		|-->return false //(page_alloc.c)
																
																|-->__count_zid_vm_events //()
																|-->zone_statistics //()
														
														|-->prep_new_page //()
													
													|-->__alloc_pages_slowpath //(page_alloc.c)
														|-->get_page_from_freelist //(page_alloc.c)
															|-->
														
														|-->__alloc_pages_direct_reclaim //(page_alloc.c)
															|-->__perform_reclaim //(page_alloc.c)
																|-->try_to_free_pages //(vmscan.c)
																	|-->do_try_to_free_pages //(vmscan.c)
																		|-->shrink_zones //(vmscan.c)

														|-->__alloc_pages_direct_compact //(page_alloc.c)			
					
													|-->kmemcheck_pagealloc_alloc //()					

										|-->pgtable_page_ctor //()
			
									|-->smp_wmb //(barrier.h) å†…å­˜å±éšœ
									|-->pmd_populate //(barrier.h)


|-->try_to_unmap //(rmap.c)
	|-->rwc.invalid_vma = invalid_migration_vma //(rmap.c)
	|-->.rmap_one = try_to_unmap_one //(rmap.c)
	|-->.done = page_mapcount_is_zero //(rmap.c)
	|-->rmap_walk_locked //()
		|-->PageAnon //(page-flags.h) è¯»å–mappingçš„æœ€ä½Žä½ï¼Œæœ€ä½Žä½ä¸?è¡¨ç¤ºè¯¥é¡µä¸ºåŒ¿åé¡µï¼Œå¦åˆ™ä¸ºæ˜ å°„é¡
		|-->rmap_walk_anon //(rmap.c) åŒ¿åé¡µå¤„ç†å‡½æ•
			|-->

		|-->rmap_walk_file //(rmap.c) æ˜ å°„é¡µå¤„ç†å‡½æ•
			|-->page_mapping //()
			|-->page_to_pgoff //()
			|-->vma_interval_tree_foreach //(mm.h)
				|-->vma_interval_tree_iter_first //()
				|-->vma_interval_tree_iter_next //()

			|-->vma_address //()
			|-->rwc->invalid_vma //(rmap.c)
				|-->invalid_migration_vma //(rmap.c)
					|-->is_vma_temporary_stack //(rmap.c)
						
			|-->rwc->rmap_one //(rmap.c)
				|-->try_to_unmap_one //(rmap.c)
					|-->page_vma_mapped_walk //(page_vma_mapped.c)
						|-->

					|-->flush_cache_page //()
						|-->

					|-->should_defer_flush //
					|-->ptep_clear_flush //()
					|-->update_hiwater_rss //(mm.h)
						|-->get_mm_rss //()

					|-->swp_entry_to_pte //(swapops.h)
						|-->__swp_entry //()
							|-->mk_swap_pte //()
						|-->__swp_entry_to_pte //()

					|-->pte_soft_dirty //()
					|-->pte_swp_mksoft_dirty //()
					|-->set_pte_at //()

					|-->page_remove_rmap //(rmap.c)
						|-->page_remove_file_rmap //(rmap.c)
							|-->

						|-->page_remove_anon_compound_rmap //()

					|-->mmu_notifier_invalidate_page //(mmu_notifier.h)
						|-->mm_has_notifiers //(mmu_notifier.h)
						|-->__mmu_notifier_invalidate_page //(mmu_notifier.c)
							|-->mn->ops->invalidate_page //(mmu_notifier.c)

			|-->rwc->done //(rmap.c)
				|-->page_mapcount_is_zero //(rmap.c)
					|-->total_mapcount //(mm.h)
						|-->page_mapcount //(mm.h)
							|-->atomic_read(&page->_mapcount) + 1 //(mm.h) åˆ¤æ–­æ˜¯å¦å±žäºŽå…±äº«é¡µé¢
		
	|-->page_mapcount //(mm.h)
		|-->tomic_read(&page->_mapcount) //è¯»å–_mapcountçš„æ•°å€?1ï¼Œè¡¨ç¤ºå½“å‰çš„é¡µæ˜¯å¦ä¸ºå…±äº«


|-->alloc_pages_node //(gfp.h)
	|-->__alloc_pages_node //(gfp.h)
		|-->__alloc_pages //(gfp.h)
			|-->__alloc_pages_nodemask //(page_alloc.c)
				|-->

|-->__perform_reclaim //(page_alloc.c)

|-->init_swap_address_space //(swap_state.c) åˆå§‹åŒ–å…¨å±€å˜é‡struct address_space
	|-->INIT_RADIX_TREE(&space->page_tree, GFP_ATOMIC|__GFP_NOWARN) //(radix-tree.h)
		|-->(root)->gfp_mask = (mask) //(radix-tree.h)
		|-->(root)->rnode = NULL //(radix-tree.h)
	
	|-->space->a_ops = &swap_aops; //(swap_state.c)
		|-->.writepage  = swap_writepage //(swap_state.c)
			|-->swap_writepage //(page_io.c)
				|-->try_to_free_swap //()
				|-->__swap_writepage //(page_io.c)
					|-->bdev_write_page //(fs/block_dev.c)
						|-->ops->rw_page //(block_dev.c) 
							|-->.rw_page = zram_rw_page //(zram_drv.c)
								|-->zram_rw_page //(zram_drv.c)
									|-->zram_bvec_rw //(zram_drv.c)
										|-->zram_bvec_read //()
										|-->zram_bvec_write //(zram_drv.c)
											|-->__zram_bvec_write //(zram_drv.c)
												|-->zcomp_compress //()
												|-->zs_malloc //()
												|-->zs_map_object //()
												|-->memcpy(dst, src, comp_len); //()
		
		|-->.set_page_dirty = swap_set_page_dirty //(swap_state.c)
		|-->.migratepage    = migrate_page //(swap_state.c)
		
	|-->mapping_set_no_writeback_tags(space) //

|-->alloc_page_buffers //(buffer.c)
	|-->free_more_memory //(buffer.c)
		|-->try_to_free_pages //(vmscan.c)
			|-->throttle_direct_reclaim //()
			|-->trace_mm_vmscan_direct_reclaim_begin //()
			|-->do_try_to_free_pages //(vmscan.c)
				|-->shrink_zones //(vmscan.c)
					|-->shrink_node //(vmscan.c)
						|-->shrink_node_memcg //(vmscan.c)
							|-->shrink_list //(vmscan.c)
								|-->shrink_active_list //(vmscan.c)
									|-->lru_add_drain //(vmscan.c) å¤„ç†lruç¼“å­˜
									|-->isolate_lru_pages //(vmscan.c) æ‰¾å‡ºunevictableä¹‹å¤–anon lru page, PG_lruæ¸…é›¶ï¼Œæš‚å­˜åˆ°ä¸€ä¸ªlistä¸­ï¼Œå¹¶ä¼ é€’ç»™skrink_page_list()
									|-->free_hot_cold_page_list //(vmscan.c) 

								|-->shrink_inactive_list //(vmscan.c)
									|-->lru_add_drain //(vmscan.c) å¤„ç†lruç¼“å­˜
									|-->isolate_lru_pages //(vmscan.c) æ‰¾å‡ºunevictableä¹‹å¤–anon lru page, PG_lruæ¸…é›¶ï¼Œæš‚å­˜åˆ°ä¸€ä¸ªlistä¸­ï¼Œå¹¶ä¼ é€’ç»™skrink_page_list()
									|-->shrink_page_list //(vmscan.c) éåŽ†page_listä¸­æ‰€æœ‰çš„page
										|-->if(PageAnon(page))
											|-->add_to_swap //(swap_state.c) åˆ†é…ä¸€ä¸ªæ–°é¡µæ§½ï¼Œå¹¶æŠŠå¶æ¡†æ’å…¥swap cache
												|-->get_swap_page //(swap_slots.c) åˆ†é…ä¸€ä¸ªæ–°é¡µæ§½ï¼Œå¹¶ä¼ é€’ç»™add_to_swap_cache()ã€‚é¡µæ§½ç»“æž„ä½“ä¸­çš„val(long)åŒ…å«SWAP_TYPEï¼Œä»¥åŠswap_info[]çš„index
													|-->get_swap_pages //(swapfile.c)
														|-->swap_alloc_cluster //(swapfile.c)
														|-->scan_swap_map_slots //(swapfile.c)
												
												|-->add_to_swap_cache //(swap_state.c)
													|-->radix_tree_maybe_preload_order //()
													|-->__add_to_swap_cache //(swap_state.c)
														|-->page_ref_add //(page_ref.h) å¢žåŠ pageçš„å¼•ç”¨è®¡æ•
														|-->swap_address_space //()
														|-->radix_tree_insert //(radix-tree.h) åŸºæ•°æ ‘ï¼Œæ“…é•¿è®°å½•key-valueï¼Œç”¨äºŽç®¡ç†äº¤æ¢åŒº
															|-->__radix_tree_insert //(radix-tree.c)
																|-->radix_tree_is_internal_node //(radix-tree.h) åšæ ¡éªŒæ£€æŸ
																|-->__radix_tree_create //(radix-tree.c)
																	|-->
																
																|-->insert_entries //(radix-tree.c)
																	|-->node_to_entry //()
																	|-->radix_tree_exceptional_entry //()
													
													|-->radix_tree_preload_end //()
													
												|-->

										|-->if(page_mapped(page)) å¯¹å…¨éƒ¨æ˜ å°„äº†è¯¥é¡µçš„è¿›ç¨‹æ‰§è¡Œå–æ¶ˆæ˜ å°„çš„æ“ä½œ
											|-->try_to_unmap //()

										|-->pageout //(vmscan.c) å¯¹æ‰€æœ‰çš„è„é¡µæ‰§è¡Œwrite back
											|-->.writepage  = swap_writepage //(swap_state.c)
												|-->swap_writepage //(page_io.c)
													|-->try_to_free_swap //()
													|-->frontswap_store //()
													|-->__swap_writepage //(page_io.c)
														|-->

									|-->free_hot_cold_page_list //(vmscan.c) 

								|-->inactive_list_is_low //(vmscan.c) æ£€æŸ¥éžæ´»åŠ¨é“¾è¡¨æ˜¯å¦è¿‡ä½Ž
									|-->if(mapping->a_ops->writepage)
										|-->mapping->a_ops->writepage(page, &wbc) //(vmscan.c) è°ƒç”¨å®šä¹‰å¥½çš„writepageå›žå†™è„é¡µ
									
								|-->shrink_active_list //(vmscan.c)
								
						|-->shrink_slab //(vmscan.c)
							|-->do_shrink_slab //(vmscan.c)
								|-->trace_mm_shrink_slab_start //()
								|-->trace_mm_shrink_slab_end //()
	
				|-->delayacct_freepages_end //(delayacct.h)
					|-->__delayacct_freepages_end //(delayacct.c)
						|-->delayacct_end //(delayacct.c)
		
			|-->trace_mm_vmscan_direct_reclaim_end //()
