|-->do_anonymous_page //(memory.c) 加载匿名页

|-->mark_page_accessed //(swap.c) 处理页标记，将其标记为访问过的页面

|-->page_referenced //(rmap.c)
	|-->.rmap_one = page_referenced_one //(rmap.c)
	|-->rwc.invalid_vma = invalid_page_referenced_vma //(rmap.c)
	|-->rmap_walk //(rmap.c) 3个分支，分别是内核、匿名映射、文件映射
		|-->rmap_walk_ksm //()
		|-->rmap_walk_anon //(rmap.c)
		|-->rmap_walk_file //(rmap.c)
			|-->rwc->invalid_vma && rwc->invalid_vma(vma, rwc->arg) //()
				|-->invalid_page_referenced_vma //(rmap.c)
					|-->mm_match_cgroup //(memcontrol.h)
						|-->mem_cgroup_from_task //()
						|-->mem_cgroup_is_descendant //()

			|-->rwc->rmap_one(page, vma, address, rwc->arg) //()
				|-->page_referenced_one //(rmap.c)
					|-->page_vma_mapped_walk //()
					|-->

|-->vma 管理 //(include/linux/mm_types.h)
struct vm_area_struct {
	unsigned long vm_start;//当前这个VMA的起始虚拟地址
	unsigned long vm_end; //vm_end是结束地址后的一个byte的地址
	struct vm_area_struct *vm_next, *vm_prev; //当前进程的所有的VMA链接起来
	pgprot_t vm_page_prot; //访问权限
};__randomize_layout;


|-->zone数据结构 //(include/linux/mmzone.h)
struct zone {
	unsigned long watermark[NR_WMARK]; //内存水位WMARK_MIN、WMARK_LOW、WMARK_HIGH
	long lowmem_reserve[MAX_NR_ZONES] //每个管理区必须保留的页框数
	struct pglist_data  *zone_pgdat; //zone的主要数据结构，内部包含lru链表和具体的数据
	unsigned long       spanned_pages; //管理区的大小,包括洞
	unsigned long       present_pages; //管理区的大小，不包括洞
	.......
};

|-->lru数据结构体 //(include/linux/mmzone.h)
	|-->NR_LRU_LISTS //(mmzone.h) 内部包含5条list
		|-->LRU_INACTIVE_ANON // 不活跃的匿名页  page->flags不带有PG_active
		|-->LRU_ACTIVE_ANON // 活跃的匿名页 page->flags带有PG_active
		|-->LRU_INACTIVE_FILE // 不活跃的文件缓存 page->flags不带有PG_active 
		|-->LRU_ACTIVE_FILE // 活跃的文件缓存 page->flags带有PG_active
		|-->LRU_UNEVICTABLE // 不可回收页 page->flags带有PG_unevictable
		
struct lruvec {
    struct list_head        lists[NR_LRU_LISTS];//内部包含5条链表，分别是LRU_INACTIVE_ANON
    struct zone_reclaim_stat    reclaim_stat;
    /* Evictions & activations on the inactive file list */
    atomic_long_t           inactive_age;
    /* Refaults at the time of last reclaim cycle */
    unsigned long           refaults;
#ifdef CONFIG_MEMCG
    struct pglist_data *pgdat;
#endif
};

|-->mmap_mem //(drivers/char/mem.c) mmap的实现
	|-->remap_pfn_range //(memory.c)
		|-->pgd_addr_end //(memory.c)
		|-->remap_p4d_range //(memory.c)
			|-->p4d_alloc //(memory.c)
			|-->p4d_addr_end //(memory.c)
			|-->remap_pud_range //(memory.c)	
				|-->pud_alloc //(memory.c)
				|-->pud_addr_end //(memory.c)
				|-->remap_pmd_range //(memory.c)
					|-->pmd_alloc //(memory.c)
					|-->pmd_addr_end //(memory.c)
					|-->remap_pte_range //(memory.c)
						|-->pte_alloc_map_lock //(mm.h)
							|-->pte_alloc //(mm.h)
								|-->__pte_alloc //(memory.c)
									|-->pte_alloc_one //(pgtable.c)
										|-->alloc_pages //(gfp.h)
											|-->alloc_pages_current //(mempolicy.c)
												|-->alloc_page_interleave //() 适用于大内存分配，然后将其清零					
												|-->__alloc_pages_nodemask //(page_alloc.c)
													|-->prepare_alloc_pages //(page_alloc.c)
														|-->gfp_zone //(gfp.h) 根据参数gfp_mask找到适合的区域(区域包括ZONE_DMA、ZONE_DMA32、ZONE_NORMAL、ZONE_HIGHMEM)
														|-->node_zonelist //(gfp.h)
														|-->gfpflags_to_migratetype //(gfp.h) 根据页面申请标志gfp_mask转换为相应的内存迁移类型
														
														|-->should_fail_alloc_page //(page_alloc.c)
															|-->should_fail //(fault-inject.c)
																|-->in_task //()
															
													|-->get_page_from_freelist //(page_alloc.c)
														|-->for_next_zone_zonelist_nodemask //(mmzone.h) 循环zone链表
														|-->node_dirty_ok //(page-writeback.c) 查看是否dirty的数量是否已经到limit
														|-->zone_watermark_fast //(page_alloc.c)
															|-->__zone_watermark_ok //(page_alloc.c)
																|-->list_empty(&area->free_list) //(page_alloc.c) 检查free_list链表是否还有节点 用于快速分配
														
														|-->zone_allows_reclaim //()
														|-->node_reclaim //()
														|-->zone_watermark_ok //()
														|-->rmqueue //(page_alloc.c)
															|-->rmqueue_pcplist //(page_alloc.c)
																|-->__rmqueue_pcplist //(page_alloc.c)
																	|-->rmqueue_bulk //(page_alloc.c)
																		|-->__rmqueue //(page_alloc.c)
																			|-->__rmqueue_smallest //(page_alloc.c)
																				|-->list_first_entry_or_null //()
																			
																			|-->trace_mm_page_alloc_zone_locked //()
																		
																		|-->check_pcp_refill //(page_alloc.c)
																			|-->check_new_page //(page_alloc.c)
																				|-->return 0;
																		
																		|-->list_add(&page->lru, list) //()
																		|-->list_add_tail(&page->lru, list) //()
																		|-->__mod_zone_page_state //(vmstat.h)
																			|-->zone_page_state_add //(vmstat.h)
																	
																	if(cold)
																		|-->list_last_entry //(list.h) 获取lru链表的尾部元素
																	else
																		|-->list_first_entry //(list.h) 插入lru链表的头部元素
																		
																	|-->list_del(&page->lru) //将page从lru链表中删除
																	|-->check_new_pcp //(page_alloc.c)
																		|-->return false //(page_alloc.c)
																
																|-->__count_zid_vm_events //()
																|-->zone_statistics //()
														
														|-->prep_new_page //()
													
													|-->__alloc_pages_slowpath //(page_alloc.c)
														|-->get_page_from_freelist //(page_alloc.c)
															|-->
														
														|-->__alloc_pages_direct_reclaim //(page_alloc.c)
															|-->__perform_reclaim //(page_alloc.c)
																|-->try_to_free_pages //(vmscan.c)
																	|-->do_try_to_free_pages //(vmscan.c)
																		|-->shrink_zones //(vmscan.c)

														|-->__alloc_pages_direct_compact //(page_alloc.c)			
					
													|-->kmemcheck_pagealloc_alloc //()					

										|-->pgtable_page_ctor //()
			
									|-->smp_wmb //(barrier.h) 内存屏障
									|-->pmd_populate //(barrier.h)


|-->try_to_unmap //(rmap.c)
	|-->rwc.invalid_vma = invalid_migration_vma //(rmap.c)
	|-->.rmap_one = try_to_unmap_one //(rmap.c)
	|-->.done = page_mapcount_is_zero //(rmap.c)
	|-->rmap_walk_locked //()
		|-->PageAnon //(page-flags.h) 读取mapping的最低位，最低位为1表示该页为匿名页，否则为映射页
		|-->rmap_walk_anon //(rmap.c) 匿名页处理函数
			|-->

		|-->rmap_walk_file //(rmap.c) 映射页处理函数
			|-->page_mapping //()
			|-->page_to_pgoff //()
			|-->vma_interval_tree_foreach //(mm.h)
				|-->vma_interval_tree_iter_first //()
				|-->vma_interval_tree_iter_next //()

			|-->vma_address //()
			|-->rwc->invalid_vma //(rmap.c)
				|-->invalid_migration_vma //(rmap.c)
					|-->is_vma_temporary_stack //(rmap.c)
						
			|-->rwc->rmap_one //(rmap.c)
				|-->try_to_unmap_one //(rmap.c)
					|-->page_vma_mapped_walk //(page_vma_mapped.c)
						|-->

					|-->flush_cache_page //()
						|-->

					|-->should_defer_flush //
					|-->ptep_clear_flush //()
					|-->update_hiwater_rss //(mm.h)
						|-->get_mm_rss //()

					|-->swp_entry_to_pte //(swapops.h)
						|-->__swp_entry //()
							|-->mk_swap_pte //()
						|-->__swp_entry_to_pte //()

					|-->pte_soft_dirty //()
					|-->pte_swp_mksoft_dirty //()
					|-->set_pte_at //()

					|-->page_remove_rmap //(rmap.c)
						|-->page_remove_file_rmap //(rmap.c)
							|-->

						|-->page_remove_anon_compound_rmap //()

					|-->mmu_notifier_invalidate_page //(mmu_notifier.h)
						|-->mm_has_notifiers //(mmu_notifier.h)
						|-->__mmu_notifier_invalidate_page //(mmu_notifier.c)
							|-->mn->ops->invalidate_page //(mmu_notifier.c)

			|-->rwc->done //(rmap.c)
				|-->page_mapcount_is_zero //(rmap.c)
					|-->total_mapcount //(mm.h)
						|-->page_mapcount //(mm.h)
							|-->atomic_read(&page->_mapcount) + 1 //(mm.h) 判断是否属于共享页面
		
	|-->page_mapcount //(mm.h)
		|-->tomic_read(&page->_mapcount) //读取_mapcount的数值+1，表示当前的页是否为共享

|-->kswapd //(vmscan.c)
	|-->balance_pgdat //(vmscan.c)
		|-->kswapd_shrink_node //(vmscan.c)
			|-->shrink_node //(vmscan.c)


|-->alloc_pages_node //(gfp.h)
	|-->__alloc_pages_node //(gfp.h)
		|-->__alloc_pages //(gfp.h)
			|-->__alloc_pages_nodemask //(page_alloc.c)
				|-->

|-->__perform_reclaim //(page_alloc.c)

|-->alloc_page_buffers //(buffer.c)
	|-->free_more_memory //(buffer.c)
		|-->try_to_free_pages //(vmscan.c)
			|-->throttle_direct_reclaim //()
			|-->trace_mm_vmscan_direct_reclaim_begin //()
			|-->do_try_to_free_pages //(vmscan.c)
				|-->shrink_zones //(vmscan.c)
					|-->shrink_node //(vmscan.c)
						|-->shrink_node_memcg //(vmscan.c)
							|-->shrink_list //(vmscan.c)
								|-->shrink_active_list //(vmscan.c)
									|-->lru_add_drain //(vmscan.c) 处理lru缓存
									|-->isolate_lru_pages //(vmscan.c) 找出unevictable之外anon lru page, PG_lru清零，暂存到一个list中，并传递给skrink_page_list()
									|-->free_hot_cold_page_list //(vmscan.c) 

								|-->shrink_inactive_list //(vmscan.c)
									|-->lru_add_drain //(vmscan.c) 处理lru缓存
									|-->isolate_lru_pages //(vmscan.c) 找出unevictable之外anon lru page, PG_lru清零，暂存到一个list中，并传递给skrink_page_list()
									|-->shrink_page_list //(vmscan.c) 遍历page_list中所有的page
										|-->if(PageAnon(page))
											|-->add_to_swap //(swap_state.c) 分配一个新页槽，并把叶框插入swap cache
												|-->get_swap_page //()
												|-->add_to_swap_cache //()
												|-->

										|-->if(page_mapped(page)) 对全部映射了该页的进程执行取消映射的操作
											|-->try_to_unmap //()

										|-->pageout //() 对所有的脏页执行write back

									|-->free_hot_cold_page_list //(vmscan.c) 

						|-->shrink_slab //(vmscan.c)
							|-->do_shrink_slab //(vmscan.c)
								|-->trace_mm_shrink_slab_start //()
								|-->trace_mm_shrink_slab_end //()
	
				|-->delayacct_freepages_end //(delayacct.h)
					|-->__delayacct_freepages_end //(delayacct.c)
						|-->delayacct_end //(delayacct.c)
		
			|-->trace_mm_vmscan_direct_reclaim_end //()
