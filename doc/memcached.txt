重要的结构体
typedef struct {
    unsigned int size;      /* sizes of items */
    unsigned int perslab;   /* how many items per slab */

    void *slots;           /* list of item ptrs */
    unsigned int sl_curr;   /* total free items in list */

    unsigned int slabs;     /* how many slabs were allocated for this class */

    void **slab_list;       /* array of slab pointers */
    unsigned int list_size; /* size of prev array */

    size_t requested; /* The number of requested bytes */
} slabclass_t; //(slabs.c)

#define MAX_NUMBER_OF_SLAB_CLASSES (63 + 1) //(memcached.h)
static slabclass_t slabclass[MAX_NUMBER_OF_SLAB_CLASSES] //(slabs.c) 全局变量

m --> settings.maxbytes
settings.item_size_max > (settings.maxbytes / 2)

|-->main //(memcached.c)
	|-->settings_init //(memcached.c) 设置默认参数，设置settings全局变量的默认参数
		|-->settings.maxbytes = 64 * 1024 * 1024 //(64M)
		|-->settings.factor = 1.25 //
		|-->settings.slab_page_size = 1024 * 1024 //
		|-->settings.slab_chunk_size_max = settings.slab_page_size / 2
		|-->settings.chunk_size = 48
		
	|-->init_lru_maintainer //(items.c) 初始化互斥锁和全局变量
		|-->pthread_mutex_init(&lru_maintainer_lock, NULL) 
		|-->lru_maintainer_initialized = 1 
	
	|-->event_init //调用libevent库，创建事件
	|-->logger_init //()
	|-->stats_init //()
	|-->assoc_init //()
	|-->conn_init //()
	|-->slabs_init(settings.maxbytes, settings.factor, preallocate, use_slab_sizes ? slab_sizes : NULL) //(slabs.c)
		|-->
		
	|-->if (settings.socketpath == NULL) //默认进入该分支
		|-->server_sockets //(memcached.c) 创建listen socket
			|-->server_socket //(memcached.c)
				|-->new_socket //(memcached.c) 创建socket并将之设置为O_NONBLOCK
				|-->setsockopt(sfd, SOL_SOCKET, SO_REUSEADDR, (void *)&flags, sizeof(flags)) 
				|-->setsockopt(sfd, SOL_SOCKET, SO_KEEPALIVE, (void *)&flags, sizeof(flags))
				|-->setsockopt(sfd, SOL_SOCKET, SO_LINGER, (void *)&ling, sizeof(ling))
				|-->setsockopt(sfd, IPPROTO_TCP, TCP_NODELAY, (void *)&flags, sizeof(flags))
				|-->conn_new //()
					|-->event_set(&c->event, sfd, event_flags, event_handler, (void *)c) //将创建的listen句柄绑定到event_handler函数
						|-->event_handler //(memcached.c) 当listener接收到数据时会调用到该函数
							|-->drive_machine //(memcached.c)
								|-->switch(c->state)
									|-->case conn_listening //监听状态，用于处理新接入的用户请求
										|-->accept
										|-->dispatch_conn_new //(thread.c)
											|-->item->init_state = conn_new_cmd //将状态机设置为conn_new_cmd，等待用户输入命令
											|-->item->mode = queue_new_conn //(threads.c) 设置mode状态机
											|-->write //通过 notify_send_fd 向pipe中写入一个字节'c'来通知对应的线程(pipe中不是原子的，所以写入一个字节确保不会出现数据紊乱)
	
	
	|-->memcached_thread_init //(thread.c)
		|-->pipe(fds) //创建管道用于通信
		|-->threads[i].notify_receive_fd = fds[0] 
		|-->threads[i].notify_send_fd = fds[1] 
		|-->setup_thread //(thread.c)
			|-->event_set(&me->notify_event, me->notify_receive_fd, EV_READ | EV_PERSIST, thread_libevent_process, me)//将notify_receive_fd绑定到thread_libevent_process
			|-->thread_libevent_process //(thread.c)
				|-->switch(switch (buf[0]))
					|-->case 'c': //
						|-->conn_new //(memcached.c)
							|-->event_handler //(memcached.c)
								|-->drive_machine //(memcached.c)
									|-->switch(c->state)
										|-->conn_new_cmd //
											|-->--nreqs //
											|-->if (nreqs >= 0)
												|-->reset_cmd_handler //(memcached.c)
													|-->conn_shrink(c) //(memcached.c) 调整内存
													|-->if (c->rbytes > 0)
														|-->conn_set_state(c, conn_parse_cmd) //正常情况下进入该状态,再次进入while循环
													|-->else
														|-->conn_set_state(c, conn_waiting)
											|-->else //(nreqs < 0)
												|-->stop = true //退出while循环
											
										|-->case conn_parse_cmd //处理用户输入的指令
											|-->ret = try_read_command //(memcached.c) 读取指令
												|-->process_command //(memcached.c)
													|-->add_msghdr //(memcached.c)
														|-->

													|-->tokenize_command //(memcached.c)
														|-->

													|-->switch(cmd)
														|-->case "get" || "bget"
															|-->process_get_command //()

														|-->case "add" || "set" || "replace" || "prepend" || "append"
															|-->process_update_command(c, tokens, ntokens, comm, false)
																|-->set_noreply_maybe //()
																|-->判断key值的长度(不能大于250),否则返回错误
																|-->item_alloc //(thread.c)
																	|-->do_item_alloc //(items.c)
																		|-->item_make_header //(items.c) 计算数据存储长度
																		|-->slabs_clsid //(slabs.c)
																			|-->通过while对比slabclass.size的大小,从而返回对应的索引值(slabclass.szie在slabs_init中预分配)
																		|-->判断种大小是否超过settings.slab_chunk_size_max
																			|-->超过
																				|-->

																			|-->不超过
																				|-->do_item_alloc_pull //(items.c)
																					|-->slabs_alloc //(slabs.c)
																						|-->do_slabs_alloc //(slabs.c)
																							|-->

																|-->
																|-->conn_set_state(c, conn_nread) //设置状态机

														|-->case "cas"
															|-->process_update_command(c, tokens, ntokens, comm, true)

														|-->case "inc"
															|-->process_arithmetic_command//

														|-->case "gets"
															|-->process_get_command //()

														|-->case "decr"
															|-->process_arithmetic_command //()

														|-->case "delete"
															|-->process_delete_command //()

														|-->case "touch"
															|-->process_touch_command //()

														|-->case "gat"
															|-->process_get_command(c, tokens, ntokens, false, true) //

														|-->case "gats"
															|-->process_get_command(c, tokens, ntokens, true, true) //

														|-->case "stats"
															|-->process_stat //()

														|-->case "flush_all"
															|-->

														|-->case "version"
															|-->out_string //

														|-->case "quit"
															|-->conn_set_state(c, conn_closing) //

														|-->case "shutdown"
															|-->

														|-->case "slabs"
															|-->
												
											|-->if(0 == ret)
												|-->conn_set_state(c, conn_waiting) //将状态置为waiting状态

		|-->create_worker(worker_libevent, &threads[i]) //(thread.c)
			|-->worker_libevent //(thread.c)
				|-->register_thread_initialized //()
			

	|-->init_lru_crawler //()

	|-->server_socket_unix //(memcached.c)
		|-->conn_new //(memcached.c)

	|-->server_sockets //(memcached.c)
		|-->server_socket //(memcached.c)
			|-->conn_new //(memcached.c)

	|-->event_base_loop //()


