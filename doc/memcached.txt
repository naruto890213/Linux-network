重要的结构体
typedef struct {
    unsigned int size;      /* sizes of items */
    unsigned int perslab;   /* how many items per slab */

    void *slots;           /* list of item ptrs */
    unsigned int sl_curr;   /* total free items in list */

    unsigned int slabs;     /* how many slabs were allocated for this class */

    void **slab_list;       /* array of slab pointers */
    unsigned int list_size; /* size of prev array */

    size_t requested; /* The number of requested bytes */
} slabclass_t; //(slabs.c)

#define MAX_NUMBER_OF_SLAB_CLASSES (63 + 1) //(memcached.h)
static slabclass_t slabclass[MAX_NUMBER_OF_SLAB_CLASSES] //(slabs.c) 全局变量

#define HOT_LRU 0 //hot数据区
#define WARM_LRU 64 //warm数据区
#define COLD_LRU 128 //cold数据区
#define TEMP_LRU 192 //没有过期时间数据区

#define CLEAR_LRU(id) (id & ~(3<<6)) //最原始的数据区,即hot数据区
#define GET_LRU(id) (id & (3<<6)) //
#define LARGEST_ID POWER_LARGEST //lru数组最大值256,即0-255

m --> settings.maxbytes
settings.item_size_max > (settings.maxbytes / 2)

|-->main //(memcached.c)
	|-->settings_init //(memcached.c) 设置默认参数，设置settings全局变量的默认参数
		|-->settings.maxbytes = 64 * 1024 * 1024 //(64M)
		|-->settings.factor = 1.25 //
		|-->settings.slab_page_size = 1024 * 1024 //
		|-->settings.slab_chunk_size_max = settings.slab_page_size / 2
		|-->settings.chunk_size = 48
		|-->settings.lru_segmented = true 
		|-->settings.hot_lru_pct = 20 
		|-->settings.warm_lru_pct = 40
		|-->settings.hot_max_factor = 0.2
		|-->settings.warm_max_factor = 2.0
		|-->settings.temp_lru = false
		
	|-->init_lru_maintainer //(items.c) 初始化互斥锁和全局变量
		|-->pthread_mutex_init(&lru_maintainer_lock, NULL) 
		|-->lru_maintainer_initialized = 1 
	
	|-->event_init //调用libevent库，创建事件
	|-->logger_init //()
	|-->stats_init //()
	|-->assoc_init //()
	|-->conn_init //()
	|-->slabs_init(settings.maxbytes, settings.factor, preallocate, use_slab_sizes ? slab_sizes : NULL) //(slabs.c)
		|-->
		
	|-->if (settings.socketpath == NULL) //默认进入该分支
		|-->server_sockets //(memcached.c) 创建listen socket
			|-->server_socket //(memcached.c)
				|-->new_socket //(memcached.c) 创建socket并将之设置为O_NONBLOCK
				|-->setsockopt(sfd, SOL_SOCKET, SO_REUSEADDR, (void *)&flags, sizeof(flags)) 
				|-->setsockopt(sfd, SOL_SOCKET, SO_KEEPALIVE, (void *)&flags, sizeof(flags))
				|-->setsockopt(sfd, SOL_SOCKET, SO_LINGER, (void *)&ling, sizeof(ling))
				|-->setsockopt(sfd, IPPROTO_TCP, TCP_NODELAY, (void *)&flags, sizeof(flags))
				|-->conn_new //()
					|-->event_set(&c->event, sfd, event_flags, event_handler, (void *)c) //将创建的listen句柄绑定到event_handler函数
						|-->event_handler //(memcached.c) 当listener接收到数据时会调用到该函数
							|-->drive_machine //(memcached.c)
								|-->switch(c->state)
									|-->case conn_listening //监听状态，用于处理新接入的用户请求
										|-->accept
										|-->dispatch_conn_new //(thread.c)
											|-->item->init_state = conn_new_cmd //将状态机设置为conn_new_cmd，等待用户输入命令
											|-->item->mode = queue_new_conn //(threads.c) 设置mode状态机
											|-->write //通过 notify_send_fd 向pipe中写入一个字节'c'来通知对应的线程(pipe中不是原子的，所以写入一个字节确保不会出现数据紊乱)
	
	
	|-->memcached_thread_init //(thread.c)
		|-->pipe(fds) //创建管道用于通信
		|-->threads[i].notify_receive_fd = fds[0] 
		|-->threads[i].notify_send_fd = fds[1] 
		|-->setup_thread //(thread.c)
			|-->event_set(&me->notify_event, me->notify_receive_fd, EV_READ | EV_PERSIST, thread_libevent_process, me)//将notify_receive_fd绑定到thread_libevent_process
			|-->thread_libevent_process //(thread.c)
				|-->switch(switch (buf[0]))
					|-->case 'c': //
						|-->conn_new //(memcached.c)
							|-->event_handler //(memcached.c)
								|-->drive_machine //(memcached.c)
									|-->switch(c->state)
										|-->conn_new_cmd //
											|-->--nreqs //
											|-->if (nreqs >= 0)
												|-->reset_cmd_handler //(memcached.c)
													|-->conn_shrink(c) //(memcached.c) 调整内存
													|-->if (c->rbytes > 0)
														|-->conn_set_state(c, conn_parse_cmd) //正常情况下进入该状态,再次进入while循环
													|-->else
														|-->conn_set_state(c, conn_waiting)
											|-->else //(nreqs < 0)
												|-->stop = true //退出while循环
											
										|-->case conn_parse_cmd //处理用户输入的指令
											|-->ret = try_read_command //(memcached.c) 读取指令
												|-->process_command //(memcached.c)
													|-->add_msghdr //(memcached.c)
														|-->

													|-->tokenize_command //(memcached.c)
														|-->

													|-->switch(cmd)
														|-->case "get" || "bget"
															|-->process_get_command //()

														|-->case "add" || "set" || "replace" || "prepend" || "append"
															|-->process_update_command(c, tokens, ntokens, comm, false)
																|-->set_noreply_maybe //()
																|-->判断key值的长度(不能大于250),否则返回错误
																|-->item_alloc //(thread.c)
																	|-->do_item_alloc //(items.c) 惰性分配
																		|-->item_make_header //(items.c) 计算数据存储长度
																		|-->slabs_clsid //(slabs.c)
																			|-->通过while对比slabclass.size的大小,从而返回对应的索引值(slabclass.szie在slabs_init中预分配)
																		|-->判断种大小是否超过settings.slab_chunk_size_max(该值默认为512K)
																			|-->超过
																				|-->

																			|-->不超过
																				|-->do_item_alloc_pull //(items.c)
																					|-->slabs_alloc //(slabs.c)
																						|-->do_slabs_alloc //(slabs.c)
																							|-->

																|-->
																|-->conn_set_state(c, conn_nread) //设置状态机

														|-->case "cas"
															|-->process_update_command(c, tokens, ntokens, comm, true)

														|-->case "inc"
															|-->process_arithmetic_command//

														|-->case "gets"
															|-->process_get_command //()

														|-->case "decr"
															|-->process_arithmetic_command //()

														|-->case "delete"
															|-->process_delete_command //()

														|-->case "touch"
															|-->process_touch_command //()

														|-->case "gat"
															|-->process_get_command(c, tokens, ntokens, false, true) //

														|-->case "gats"
															|-->process_get_command(c, tokens, ntokens, true, true) //

														|-->case "stats"
															|-->process_stat //()

														|-->case "flush_all"
															|-->

														|-->case "version"
															|-->out_string //

														|-->case "quit"
															|-->conn_set_state(c, conn_closing) //

														|-->case "shutdown"
															|-->

														|-->case "slabs"
															|-->
												
											|-->if(0 == ret)
												|-->conn_set_state(c, conn_waiting) //将状态置为waiting状态

		|-->create_worker(worker_libevent, &threads[i]) //(thread.c)
			|-->worker_libevent //(thread.c)
				|-->register_thread_initialized //()
			
	|-->start_assoc_maintenance_thread //(assoc.c) 默认开启该线程
		|-->assoc_maintenance_thread //(assoc.c)
			|-->pthread_cond_wait(&maintenance_cond, &maintenance_lock) //(assoc.c) 等待条件变量
	
	|-->start_item_crawler_thread //(crawler.c)  默认开启该线程
		|-->item_crawler_thread //
	
	|-->start_slab_maintenance_thread //(slabs.c)
		|-->pthread_cond_init(&slab_rebalance_cond, NULL) //初始化条件变量
		|-->slab_rebalance_thread //(slabs.c)
			|-->while (do_run_slab_rebalance_thread) //loop
				|-->if (slab_rebalance_signal == 1)
					|-->if (slab_rebalance_start() < 0)
						|-->slab_rebalance_signal  = 1
				
					|-->was_busy = 0
					
				|-->else if (slab_rebalance_signal && slab_rebal.slab_start != NULL)
					|-->was_busy = slab_rebalance_move
						|-->
						
				|-->if (slab_rebal.done)
					|-->slab_rebalance_finish //()
					
				|-->else if (was_busy)
					|-->usleep(1000)
					
				|-->if (slab_rebalance_signal == 0)
					|-->pthread_cond_wait(&slab_rebalance_cond, &slabs_rebalance_lock) //等待唤醒
	
	|-->start_conn_timeout_thread //()
	
	|-->clock_handler //(memcached.c)
		|-->assoc_start_expand //(assoc.c)
			|-->if (curr_items > (hashsize(hashpower) * 3) / 2 && hashpower < HASHPOWER_MAX)
				|-->pthread_cond_signal(&maintenance_cond) //发送信号，唤醒assoc_maintenance_thread线程

	|-->server_socket_unix //(memcached.c)
		|-->conn_new //(memcached.c)

	|-->server_sockets //(memcached.c)
		|-->server_socket //(memcached.c)
			|-->conn_new //(memcached.c)

	|-->event_base_loop //(memcached.c) 阻塞在这里，具体实现参见libevent实现
	
	
|-->stop_assoc_maintenance_thread //(assoc.c)
	|-->do_run_maintenance_thread = 0 //设置while 循环退出变量值
	|-->pthread_cond_signal(&maintenance_cond) //发送信号
	
|-->do_slabs_reassign //(slabs.c)
	|-->slab_rebalance_signal = 1
	|-->pthread_cond_signal(&slab_rebalance_cond) //发送信号
	
|-->stop_slab_maintenance_thread //(slabs.c)
	|-->do_run_slab_thread = 0
	|-->do_run_slab_rebalance_thread = 0
	|-->pthread_cond_signal(&slab_rebalance_cond) //发送信号，以便唤醒线程并退出

typedef struct {
    slab_automove_init_func init;
    slab_automove_free_func free;
    slab_automove_run_func run;
} slab_automove_reg_t; //(slab_automove.h)

slab_automove_reg_t slab_automove_default = {
    .init = slab_automove_init,
    .free = slab_automove_free,
    .run = slab_automove_run
};

|-->start_item_crawler_thread //(crawler.c)
	|-->item_crawler_thread //(crawler.c)
		|-->

|-->start_lru_maintainer_thread //(items.c)
	|-->lru_maintainer_thread //(items.c) 创建线程
		|-->slab_automove_reg_t *sam = &slab_automove_default //
			|-->sam->init //(items.c)
				|-->slab_automove_init //(slab_automove.c)
					|-->

			|-->sam->run //(items.c)
				|-->slab_automove_run //(slab_automove.c)
					|-->

|-->do_item_get //(items.c)
	|-->if (is_flushed) //这个item是否在flush_all之前,如果是,则删除
		|-->do_item_unlink //
		|-->do_item_remove //

	|-->else if(it->exptime != 0 && it->exptime <= current_time) //这个item是否过期,过期则删除
		|-->do_item_unlink //
		|-->do_item_remove //

	|-->else //如果这个item没有在flush_all之前也没有过期,则标注为活跃item
		|-->do_item_update //
		

|-->process_lru_command //(memcached.c)
	|-->settings.hot_lru_pct = pct_hot;
    |-->settings.warm_lru_pct = pct_warm;
    |-->settings.hot_max_factor = hot_factor;
    |-->settings.warm_max_factor = factor;
