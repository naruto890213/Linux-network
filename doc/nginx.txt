|-----------------------重要数据结构-------------------------------------
|-->typedef struct ngx_module_s          ngx_module_t
|-->typedef struct ngx_conf_s            ngx_conf_t
|-->typedef struct ngx_cycle_s           ngx_cycle_t
|-->typedef struct ngx_pool_s            ngx_pool_t
|-->typedef struct ngx_chain_s           ngx_chain_t
|-->typedef struct ngx_log_s             ngx_log_t
|-->typedef struct ngx_open_file_s       ngx_open_file_t
|-->typedef struct ngx_command_s         ngx_command_t
|-->typedef struct ngx_file_s            ngx_file_t
|-->typedef struct ngx_event_s           ngx_event_t
|-->typedef struct ngx_event_aio_s       ngx_event_aio_t
|-->typedef struct ngx_connection_s      ngx_connection_t
|-->typedef struct ngx_thread_task_s     ngx_thread_task_t
|-->typedef struct ngx_ssl_s             ngx_ssl_t
|-->typedef struct ngx_ssl_connection_s  ngx_ssl_connection_t
|-->typedef struct ngx_udp_connection_s  ngx_udp_connection_t
|-->typedef u_char *(*ngx_log_handler_pt) (ngx_log_t *log, u_char *buf, size_t len)
|-->typedef void (*ngx_log_writer_pt) (ngx_log_t *log, ngx_uint_t level, u_char *buf, size_t len)
|-->#define NGX_ERROR_LOG_PATH  "logs/error.log"


|-->log文件操作数据结构体ngx_open_file_s //(ngx_conf_file.h)
	|-->struct ngx_open_file_s {
		ngx_fd_t              fd;
		ngx_str_t             name;

		void                (*flush)(ngx_open_file_t *file, ngx_log_t *log); //flush函数指针
		void                 *data;
	};


|-->log数据结构体ngx_log_s //(ngx_log.h)
	|-->struct ngx_log_s {
		ngx_uint_t           log_level;  
		ngx_open_file_t     *file;       

		ngx_atomic_uint_t    connection; 

		time_t               disk_full_time;

		ngx_log_handler_pt   handler; //函数指针 指针 
		void                *data;       

		ngx_log_writer_pt    writer;     
		void                *wdata;

		/*
		 * we declare "action" as "char *" because the actions are usually
		 * the static strings and in the "u_char *" case we have to override
		 * their types all the time
		 */ 

		char                *action;

		ngx_log_t           *next;
	};


|-->ngx_cycle数据结构体ngx_cycle_s //(ngx_cycle.h)
	|-->struct ngx_cycle_s {
		void                  ****conf_ctx;
		ngx_pool_t               *pool;

		ngx_log_t                *log;
		ngx_log_t                 new_log;

		ngx_uint_t                log_use_stderr;  /* unsigned  log_use_stderr:1; */

		ngx_connection_t        **files;
		ngx_connection_t         *free_connections;
		ngx_uint_t                free_connection_n;

		ngx_module_t            **modules;
		ngx_uint_t                modules_n;
		ngx_uint_t                modules_used;    /* unsigned  modules_used:1; */

		ngx_queue_t               reusable_connections_queue;
		ngx_uint_t                reusable_connections_n;

		ngx_array_t               listening;
		ngx_array_t               paths;

		ngx_array_t               config_dump;
		ngx_rbtree_t              config_dump_rbtree;
		ngx_rbtree_node_t         config_dump_sentinel;

		ngx_list_t                open_files;
		ngx_list_t                shared_memory;

		ngx_uint_t                connection_n;
		ngx_uint_t                files_n;
		ngx_connection_t         *connections;
		ngx_event_t              *read_events;
		ngx_event_t              *write_events;

		ngx_cycle_t              *old_cycle;

		ngx_str_t                 conf_file;
		ngx_str_t                 conf_param;
		ngx_str_t                 conf_prefix;
		ngx_str_t                 prefix;
		ngx_str_t                 lock_file;
		ngx_str_t                 hostname;
	};

|-->ngx_event_actions事件处理结构体(对应不同清空的执行动作) //(ngx_event.h)
	|-->typedef struct {
		ngx_int_t  (*add)(ngx_event_t *ev, ngx_int_t event, ngx_uint_t flags);
		ngx_int_t  (*del)(ngx_event_t *ev, ngx_int_t event, ngx_uint_t flags);

		ngx_int_t  (*enable)(ngx_event_t *ev, ngx_int_t event, ngx_uint_t flags);
		ngx_int_t  (*disable)(ngx_event_t *ev, ngx_int_t event, ngx_uint_t flags);

		ngx_int_t  (*add_conn)(ngx_connection_t *c);
		ngx_int_t  (*del_conn)(ngx_connection_t *c, ngx_uint_t flags);

		ngx_int_t  (*notify)(ngx_event_handler_pt handler);

		ngx_int_t  (*process_events)(ngx_cycle_t *cycle, ngx_msec_t timer,
									 ngx_uint_t flags);

		ngx_int_t  (*init)(ngx_cycle_t *cycle, ngx_msec_t timer);
		void       (*done)(ngx_cycle_t *cycle);
	} ngx_event_actions_t; 

|-->ngx_event_module事件结构体(包含配置创建和初始化) //(ngx_event.h)
	|-->typedef struct {
		ngx_str_t              *name;        
			
		void                 *(*create_conf)(ngx_cycle_t *cycle);
		char                 *(*init_conf)(ngx_cycle_t *cycle, void *conf);

		ngx_event_actions_t     actions;     
	} ngx_event_module_t;
	
|-->ngx_module module结构体 //(ngx_module.h)
	|-->struct ngx_module_s {
		ngx_uint_t            ctx_index;
		ngx_uint_t            index;

		char                 *name;

		ngx_uint_t            spare0;
		ngx_uint_t            spare1;

		ngx_uint_t            version;
		const char           *signature;

		void                 *ctx;
		ngx_command_t        *commands;
		ngx_uint_t            type;

		ngx_int_t           (*init_master)(ngx_log_t *log);

		ngx_int_t           (*init_module)(ngx_cycle_t *cycle);

		ngx_int_t           (*init_process)(ngx_cycle_t *cycle);
		ngx_int_t           (*init_thread)(ngx_cycle_t *cycle);
		void                (*exit_thread)(ngx_cycle_t *cycle);
		void                (*exit_process)(ngx_cycle_t *cycle);

		void                (*exit_master)(ngx_cycle_t *cycle);

		uintptr_t             spare_hook0;
		uintptr_t             spare_hook1;
		uintptr_t             spare_hook2;
		uintptr_t             spare_hook3;
		uintptr_t             spare_hook4;
		uintptr_t             spare_hook5;
		uintptr_t             spare_hook6;
		uintptr_t             spare_hook7;
	};
	
|-->static ngx_event_module_t  ngx_epoll_module_ctx = {
    &epoll_name,
    ngx_epoll_create_conf,               /* create configuration */
    ngx_epoll_init_conf,                 /* init configuration */

    {
        ngx_epoll_add_event,             /* add an event */
        ngx_epoll_del_event,             /* delete an event */
        ngx_epoll_add_event,             /* enable an event */
        ngx_epoll_del_event,             /* disable an event */
        ngx_epoll_add_connection,        /* add an connection */
        ngx_epoll_del_connection,        /* delete an connection */
#if (NGX_HAVE_EVENTFD)
        ngx_epoll_notify,                /* trigger a notify */
#else
        NULL,                            /* trigger a notify */
#endif
        ngx_epoll_process_events,        /* process the events */
        ngx_epoll_init,                  /* init the events */
        ngx_epoll_done,                  /* done the events */
    }
};

#define NGX_CORE_MODULE      0x45524F43
#define NGX_EVENT_MODULE     0x544E5645

ngx_module_t  ngx_epoll_module = {
    NGX_MODULE_V1,
    &ngx_epoll_module_ctx,               /* module context */
    ngx_epoll_commands,                  /* module directives */
    NGX_EVENT_MODULE,                    /* module type */
    NULL,                                /* init master */
    NULL,                                /* init module */
    NULL,                                /* init process */
    NULL,                                /* init thread */
    NULL,                                /* exit thread */
    NULL,                                /* exit process */
    NULL,                                /* exit master */
    NGX_MODULE_V1_PADDING
};

ngx_module_t  ngx_event_core_module = {
    NGX_MODULE_V1,
    &ngx_event_core_module_ctx,            /* module context */
    ngx_event_core_commands,               /* module directives */
    NGX_EVENT_MODULE,                      /* module type */
    NULL,                                  /* init master */
    ngx_event_module_init,                 /* init module */
    ngx_event_process_init,                /* init process */
    NULL,                                  /* init thread */
    NULL,                                  /* exit thread */
    NULL,                                  /* exit process */
    NULL,                                  /* exit master */
    NGX_MODULE_V1_PADDING
}; //(ngx_event.c) evnet事件的核心定义，其包含epoll结构体的关联

static ngx_event_module_t  ngx_event_core_module_ctx = {
    &event_core_name,
    ngx_event_core_create_conf,            /* create configuration */
    ngx_event_core_init_conf,              /* init configuration */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL }
};//(ngx_event.c)

static ngx_command_t  ngx_http_commands[] = {
    { ngx_string("http"),
      NGX_MAIN_CONF|NGX_CONF_BLOCK|NGX_CONF_NOARGS,
      ngx_http_block,
      0,
      0,
      NULL },

      ngx_null_command
}; //http模块解析指令

static ngx_core_module_t  ngx_http_module_ctx = {
    ngx_string("http"),
    NULL,
    NULL
};

ngx_module_t  ngx_http_module = {
    NGX_MODULE_V1,
    &ngx_http_module_ctx,                  /* module context */
    ngx_http_commands,                     /* module directives */
    NGX_CORE_MODULE,                       /* module type */
    NULL,                                  /* init master */
    NULL,                                  /* init module */
    NULL,                                  /* init process */
    NULL,                                  /* init thread */
    NULL,                                  /* exit thread */
    NULL,                                  /* exit process */
    NULL,                                  /* exit master */
    NGX_MODULE_V1_PADDING
};


|-->command指令集 //(ngx_conf_file.h)
	|-->struct ngx_command_s {
	    ngx_str_t             name;
	    ngx_uint_t            type;
	    char               *(*set)(ngx_conf_t *cf, ngx_command_t *cmd, void *conf);
	    ngx_uint_t            conf;
	    ngx_uint_t            offset;
	    void                 *post;
	};

ngx_module_t *ngx_modules[] = {
    &ngx_core_module,
    &ngx_errlog_module,
    &ngx_conf_module,
    &ngx_regex_module,
    &ngx_events_module,
    &ngx_event_core_module,
    &ngx_epoll_module,
    &ngx_http_module,
    &ngx_http_core_module,
    &ngx_http_log_module,
    &ngx_http_upstream_module,
    &ngx_http_static_module,
    &ngx_http_autoindex_module,
    &ngx_http_index_module,
    &ngx_http_mirror_module,
    &ngx_http_try_files_module,
    &ngx_http_auth_basic_module,
    &ngx_http_access_module,
    &ngx_http_limit_conn_module,
    &ngx_http_limit_req_module,
    &ngx_http_geo_module,
    &ngx_http_map_module,
    &ngx_http_split_clients_module,
    &ngx_http_referer_module,
    &ngx_http_rewrite_module,
    &ngx_http_proxy_module,
    &ngx_http_fastcgi_module,
    &ngx_http_uwsgi_module,
    &ngx_http_scgi_module,
    &ngx_http_memcached_module,
    &ngx_http_empty_gif_module,
    &ngx_http_browser_module,
    &ngx_http_upstream_hash_module,
	&ngx_http_upstream_ip_hash_module,
    &ngx_http_upstream_least_conn_module,
    &ngx_http_upstream_random_module,
    &ngx_http_upstream_keepalive_module,
    &ngx_http_upstream_zone_module,
    &ngx_http_write_filter_module,
    &ngx_http_header_filter_module,
    &ngx_http_chunked_filter_module,
    &ngx_http_range_header_filter_module,
    &ngx_http_gzip_filter_module,
    &ngx_http_postpone_filter_module,
    &ngx_http_ssi_filter_module,
    &ngx_http_charset_filter_module,
    &ngx_http_userid_filter_module,
    &ngx_http_headers_filter_module,
    &ngx_http_copy_filter_module,
    &ngx_http_range_body_filter_module,
    &ngx_http_not_modified_filter_module,
    NULL
}; //(objs/ngx_modules.c) 所有module的集合

ngx_os_io_t ngx_os_io = {
    ngx_unix_recv,
    ngx_readv_chain,
    ngx_udp_unix_recv,
    ngx_unix_send,
    ngx_udp_unix_send,
    ngx_udp_unix_sendmsg_chain,
    ngx_writev_chain,
    0
};//(ngx_posix_init.c) linux系统下的默认socket操作函数组

static ngx_http_module_t  ngx_http_core_module_ctx = {
    ngx_http_core_preconfiguration,        /* preconfiguration */
    ngx_http_core_postconfiguration,       /* postconfiguration */

    ngx_http_core_create_main_conf,        /* create main configuration */
    ngx_http_core_init_main_conf,          /* init main configuration */

    ngx_http_core_create_srv_conf,         /* create server configuration */
    ngx_http_core_merge_srv_conf,          /* merge server configuration */

    ngx_http_core_create_loc_conf,         /* create location configuration */
    ngx_http_core_merge_loc_conf           /* merge location configuration */
};//(ngx_http_core_module.c) http模块的配置处理函数

ngx_module_t  ngx_http_core_module = {
    NGX_MODULE_V1,
    &ngx_http_core_module_ctx,             /* module context */
    ngx_http_core_commands,                /* module directives */
    NGX_HTTP_MODULE,                       /* module type */
    NULL,                                  /* init master */
    NULL,                                  /* init module */
    NULL,                                  /* init process */
    NULL,                                  /* init thread */
    NULL,                                  /* exit thread */
    NULL,                                  /* exit process */
    NULL,                                  /* exit master */
    NGX_MODULE_V1_PADDING
};//(ngx_http_core_module.c) http的核心处理模块

//ngx_thread_pool_module 线程池模块 //(ngx_thread_pool.c) 默认是不启用的，需要在configure时进行配置--with-threads进行开启
ngx_module_t  ngx_thread_pool_module = {
    NGX_MODULE_V1,
    &ngx_thread_pool_module_ctx,           /* module context */
    ngx_thread_pool_commands,              /* module directives */
    NGX_CORE_MODULE,                       /* module type */
    NULL,                                  /* init master */
    NULL,                                  /* init module */
    ngx_thread_pool_init_worker,           /* init process */
    NULL,                                  /* init thread */
    NULL,                                  /* exit thread */
    ngx_thread_pool_exit_worker,           /* exit process */
    NULL,                                  /* exit master */
    NGX_MODULE_V1_PADDING
}; 

ngx_module_t  ngx_http_upstream_module = {
    NGX_MODULE_V1,
    &ngx_http_upstream_module_ctx,         /* module context */
    ngx_http_upstream_commands,            /* module directives */
    NGX_HTTP_MODULE,                       /* module type */
    NULL,                                  /* init master */
    NULL,                                  /* init module */
    NULL,                                  /* init process */
    NULL,                                  /* init thread */
    NULL,                                  /* exit thread */
    NULL,                                  /* exit process */
    NULL,                                  /* exit master */
    NGX_MODULE_V1_PADDING
};//(ngx_http_upstream.c)负载均衡模块


|-->main //(nginx.c) nginx函数入口
	|-->ngx_max_sockets = -1 
	|-->ngx_time_init //
	|-->ngx_regex_init //默认NGX_PCRE为true
	|-->ngx_log_init //(ngx_log.c)
		|-->ngx_log.file = &ngx_log_file 
		|-->ngx_log.log_level = NGX_LOG_NOTICE //设置打印等级
		|-->name = (u_char *) NGX_ERROR_LOG_PATH //获取文件名称
		|-->ngx_log_file.fd = ngx_open_file(name, NGX_FILE_APPEND,
                                    NGX_FILE_CREATE_OR_OPEN,
                                    NGX_FILE_DEFAULT_ACCESS) //打开文件, 当文件不存在时创建文件
									
		|-->return &ngx_log //返回ngx_log的地址
		
	|-->ngx_memzero(&init_cycle, sizeof(ngx_cycle_t)) //清空init_cycle
	|-->init_cycle.log = log //将ngx_log的地址赋值给init_cycle.log
	|-->ngx_cycle = &init_cycle //
	
	|-->init_cycle.pool = ngx_create_pool //
	
	|-->ngx_process_options //
	
	|-->ngx_os_init //(ngx_posix_init.c)
		|-->ngx_inherited_nonblocking = 0 //设置变量
	
	|-->ngx_crc32_table_init //(ngx_crc32.c)
		|-->ngx_crc32_table_short //对该值进行初始化赋值
	
	|-->ngx_slab_sizes_init //(ngx_slab.c)
		|-->ngx_slab_max_size = ngx_pagesize / 2
		|-->ngx_slab_exact_size = ngx_pagesize / (8 * sizeof(uintptr_t))
	
	|-->ngx_add_inherited_sockets //(nginx.c)
		|-->ngx_array_init(&cycle->listening, cycle->pool, 10, sizeof(ngx_listening_t) //(ngx_array.h)
			|-->array->nelts = 0 
			|-->array->pool = pool
			|-->array->elts = ngx_palloc(pool, n * size) //对cycle->listening.elts进行分配，10个地址大小
		
		|-->ngx_inherited = 1 //赋值，后面的流程需要用到
		
		|-->ngx_set_inherited_sockets //(ngx_connection.c)
			|-->ls = cycle->listening.elts
			|-->for (i = 0; i < cycle->listening.nelts; i++) //进不去，nelts的值为0
	
	|-->ngx_preinit_modules //(ngx_module.c)
		|-->for (i = 0; ngx_modules[i]; i++) //获取
			|-->ngx_modules[i]->index = i;
			|-->ngx_modules[i]->name = ngx_module_names[i];

		|-->ngx_modules_n = i //统计当前的module数量，用于后面的拷贝复制
		|-->ngx_max_module = ngx_modules_n + NGX_MAX_DYNAMIC_MODULES
	
	|-->ngx_init_cycle //(ngx_cycle.c)
		|-->ngx_array_init(&cycle->listening, pool, n, sizeof(ngx_listening_t) //初始化listening
		|-->ngx_memzero(cycle->listening.elts, n * sizeof(ngx_listening_t))
		|-->ngx_queue_init(&cycle->reusable_connections_queue) //对队列进行初始化
		|-->cycle->conf_ctx = ngx_pcalloc(pool, ngx_max_module * sizeof(void *)) //分配空间
		
		|-->ngx_cycle_modules //(ngx_module.c)
			|-->cycle->modules = ngx_pcalloc(cycle->pool, (ngx_max_module + 1) * sizeof(ngx_module_t *)) //分配空间
			|-->ngx_memcpy(cycle->modules, ngx_modules, ngx_modules_n * sizeof(ngx_module_t *)) //将全局module拷贝到cycle->modules
			|-->cycle->modules_n = ngx_modules_n //当前module的数量
		
		|-->for (i = 0; cycle->modules[i]; i++) //对modules进行轮训判断其type值
			|-->if (cycle->modules[i]->type != NGX_CORE_MODULE) //对modules进行轮训判断其type值
				|-->continue //只要type=NGX_CORE_MODULE的module
			
			|-->module = cycle->modules[i]->ctx //获取结构体中ngx_event_module_t成员, 本次分析以ngx_event_core_module_ctx为例子
			|-->if (module->create_conf) //如果create_conf回调函数存在则调用回调
				module->create_conf //调用关联模块的回调函数
					|-->case ngx_core_module: //核心模块
						|-->ngx_core_module_create_conf //(nginx.c)
							|-->ccf->daemon = NGX_CONF_UNSET //初始化
							|-->ccf->master = NGX_CONF_UNSET //初始化
							|-->ccf->worker_processes = NGX_CONF_UNSET 
							
					|-->case ngx_regex_module: //反向连接模块
						|-->ngx_regex_create_conf //(ngx_regex.c)
						
					|-->case ngx_thread_pool_module: //线程池模块
						|-->ngx_thread_pool_create_conf //(ngx_thread_pool.c)
		
		|-->conf.args = ngx_array_create(pool, 10, sizeof(ngx_str_t)) 
		|-->conf.temp_pool = ngx_create_pool(NGX_CYCLE_POOL_SIZE, log)
		
		|-->conf.module_type = NGX_CORE_MODULE
		|-->conf.cmd_type = NGX_MAIN_CONF

		|-->ngx_conf_param //(ngx_conf_file.c)
			|-->param = &cf->cycle->conf_param
			|-->ngx_memzero(&b, sizeof(ngx_buf_t))//清空结构体b
			|-->ngx_memzero(&conf_file, sizeof(ngx_conf_file_t))
			|-->b.start = param->data
			|-->b.pos = param->data
			|-->b.last = param->data + param->len
			|-->b.end = b.last
			|-->b.temporary = 1
			|-->conf_file.file.fd = NGX_INVALID_FILE
			|-->conf_file.file.name.data = NULL
			|-->conf_file.line = 0
			|-->cf->conf_file = &conf_file
			|-->cf->conf_file->buffer = &b 
			|-->ngx_conf_parse(cf, NULL) //(ngx_conf_file.c) 对cf进行解析
			|-->cf->conf_file = NULL //
			
		|-->ngx_conf_parse //(ngx_conf_file.c)
			|-->if (filename) //filename是传入的第二个参数
				|-->fd = ngx_open_file(filename->data, NGX_FILE_RDONLY, NGX_FILE_OPEN, 0) //打开文件，实际调用的就是open函数, 返回fd
				|-->if(fd == NGX_INVALID_FILE)
					|-->return NGX_CONF_ERROR;
					
				|-->prev = cf->conf_file //使用prev将cf中的原始文件信息保存起来
				|-->cf->conf_file = &conf_file //使用一个新的变量
				
				|-->ngx_fd_info(fd, &cf->conf_file->file.info) //读取文件属性(实际调用的是fstat，读取文件的属性)
				|-->cf->conf_file->buffer = &buf //使用buf进行存储
				|-->buf.start = ngx_alloc(NGX_CONF_BUFFER, cf->log) //进行空间分配
				|-->buf.pos = buf.start
				|-->buf.last = buf.start
				|-->buf.end = buf.last + NGX_CONF_BUFFER //NGX_CONF_BUFFER = 4096, 指定偏移量
				|-->buf.temporary = 1
				|-->cf->conf_file->file.fd = fd //将fd进行赋值
				|-->cf->conf_file->file.name.len = filename->len
				|-->cf->conf_file->file.name.data = filename->data
				|-->cf->conf_file->file.offset = 0
				|-->cf->conf_file->file.log = cf->log
				|-->cf->conf_file->line = 1
				|-->type = parse_file //设置类型为文件解析
				
			|-->else if (cf->conf_file->file.fd != NGX_INVALID_FILE) //如果filename为空，但fd不为初始值
				|-->type = parse_block //设置为解析block
				
			|-->else //如果filename为空，且cf->conf_file->file.fd为NGX_INVALID_FILE
				|-->type = parse_param //设置为解析参数
				
			|-->for ( ;; )
				|-->rc = ngx_conf_read_token(cf) //(ngx_conf_file.c)
					|-->cf->args->nelts = 0
					|-->start = b->pos
					|-->start_line = cf->conf_file->line
					|-->file_size = ngx_file_size(&cf->conf_file->file.info) //获取文件大小
						
				|-->ngx_conf_handler //(ngx_conf_file.c)
					|-->name = cf->args->elts
					
					|-->for (i = 0; cf->cycle->modules[i]; i++)
						|-->cmd = cf->cycle->modules[i]->commands //获取所有modules模块的cmd命令
						|-->if (cmd == NULL)
							|-->continue
							
						|-->for ( /* void */ ; cmd->name.len; cmd++)
							|-->if (name->len != cmd->name.len)
								|-->continue
								
							|-->if (ngx_strcmp(name->data, cmd->name.data) != 0)
								|-->continue
								
							|-->found = 1
							
							|-->if (cf->cycle->modules[i]->type != NGX_CONF_MODULE && cf->cycle->modules[i]->type != cf->module_type)
								|-->continue
					
							|-->if (!(cmd->type & cf->cmd_type))
								|-->continue
								
							|-->if ((cmd->type & NGX_CONF_BLOCK) && last != NGX_CONF_BLOCK_START)
								|-->return NGX_ERROR
								
							|-->cmd->set(cf, cmd, conf) //调用cmd中的set回调函数
								|-->case ngx_http_commands: //http的cmd
									|-->ngx_http_block // 主要是解析http相关的配置文件和设置accpet的回调函数

								|-->case ngx_http_core_commands: 
									|-->case "server":
										|-->ngx_http_core_server //配置文件中server字段的处理函数

									|-->case "listen":
										|-->ngx_http_core_listen //(ngx_http_core_module.c)

		|-->for (i = 0; cycle->modules[i]; i++) //对全局modules指针数组进行轮巡
			|-->if (cycle->modules[i]->type != NGX_CORE_MODULE)
				|-->continue //只要type=NGX_CORE_MODULE的module
				
			|-->module = cycle->modules[i]->ctx 
			|-->if (module->init_conf) //如果create_conf回调函数存在则调用回调
				|-->module->init_conf //调用各个关联模块的回调函数
					|-->case ngx_core_module:
						|-->ngx_core_module_init_conf //(ngx_event.c)
							|-->ngx_conf_init_value(ccf->daemon, 1)
							|-->ngx_conf_init_value(ccf->master, 1) //(ngx_conf_file.h)
								|-->if (conf == NGX_CONF_UNSET)
									|-->ccf->master = 1 //设置master的值为1，该值在后面用来判断ngx_process工作类型
									
							|-->ngx_conf_init_value(ccf->worker_processes, 1) //将worker_processes的值设置为1
							
					|-->case ngx_regex_module:
						|-->ngx_regex_init_conf //()
					
					|-->ngx_events_module:
						|-->ngx_event_init_conf //(ngx_event.c)
							|-->ngx_get_conf(cycle->conf_ctx, ngx_events_module) //(ngx_event.c)
								|-->return conf_ctx[module.index] //(ngx_conf_file.h)
			
					|-->ngx_thread_pool_module //线程池模块
						|-->ngx_thread_pool_init_conf //(ngx_thread_pool.c)
			
		|-->ngx_open_listening_sockets //(ngx_connection.c)
		|-->if (!ngx_test_config)			
			|-->ngx_configure_listening_sockets //(ngx_connection.c)

		|-->ngx_init_modules //(ngx_module.c)
			|-->for (i = 0; cycle->modules[i]; i++)
				|-->if (cycle->modules[i]->init_module)
					|-->cycle->modules[i]->init_module(cycle)
						|-->case ngx_event_core_module: 
							|-->ngx_event_module_init //()
								|-->ngx_shmtx_create(&ngx_accept_mutex, (ngx_shmtx_sh_t *) shared, cycle->lock_file.data)
									|-->mtx->lock = &addr->lock; //addr=shared
									|-->sem_init(&mtx->sem, 1, 0)
		
	|-->ngx_os_status //(ngx_posix_init.c) //打印一些os的状态值
	
	|-->ccf = (ngx_core_conf_t *) ngx_get_conf(cycle->conf_ctx, ngx_core_module) //获取ngx_core_module中索引值的conf_ctx
	
	|-->if (ccf->master && ngx_process == NGX_PROCESS_SINGLE) //master的值在init中被设置为1，ngx_process原始默认为0 
		|-->ngx_process = NGX_PROCESS_MASTER //默认情况下会进入设置该状态

	|-->ngx_init_signals //(ngx_process.c) 
		|-->for (sig = signals; sig->signo != 0; sig++) //对signals数组进行遍历，并设置其signal信号执行函数
			|-->if (sig->handler) //如果设置了回调函数，则将其添加到回调函数中
				|-->sa.sa_sigaction = sig->handler
				|-->sa.sa_flags = SA_SIGINFO
			|-->else
				|-->sa.sa_handler = SIG_IGN
				
			|-->sigemptyset(&sa.sa_mask)
			|-->sigaction //设置信号执行函数
	
	|-->if (ngx_inherited) //在上面的流程中被设置
		|-->ngx_daemonized = 1 //设置daemon
	
	|-->ngx_create_pidfile //()
	
	|-->ngx_log_redirect_stderr //()
		
	|-->if (ngx_process == NGX_PROCESS_SINGLE) //默认不进入该状态
		|-->ngx_single_process_cycle
	
	|-->else //当ngx_process不等于NGX_PROCESS_SINGLE时进入该分支。默认进入该分支
		|-->ngx_master_process_cycle //(ngx_process_cycle.c)
			|-->ccf = (ngx_core_conf_t *) ngx_get_conf(cycle->conf_ctx, ngx_core_module) //获取conf_ctx[0]
			|-->ngx_start_worker_processes //启动工作进程, 进程数量来自配置文件
			|-->ngx_start_cache_manager_processes(cycle, 0) //(ngx_process_cycle.c)
			|-->for ( ;; ) //父进程进入loop循环
					

|-------------------nginx重要的函数实现解析---------------------------|					
|-->ngx_start_worker_processes //(ngx_process_cycle.c)
	|-->for (i = 0; i < n; i++) //worker_processes的数值来自nginx.conf文件的配置,默认为1
		|-->ngx_spawn_process //创建进程,并使用传入的函数作为进程执行函数
			|-->ngx_process_slot = s
			|-->pid = fork()
			|-->switch (pid)
				|-->case -1://创建失败
					|-->NGX_INVALID_PID
					
				|-->case 0://子进程
					|-->ngx_parent = ngx_pid
					|-->ngx_pid = ngx_getpid()
					|-->proc(cycle, data) //执行传入的函数指针
						|-->ngx_worker_process_cycle //实际执行的函数为这个
															
				|-->default: //父进程
					|-->break //不做任何动作，直接break
					
			|-->return pid
			
		|-->ngx_pass_open_channel //

|-->ngx_worker_process_cycle //(ngx_process_cycle.c) 工作进程的主函数
	|-->ngx_process = NGX_PROCESS_WORKER //将其设置为NGX_PROCESS_WORKER
	|-->ngx_worker = worker
	|-->ngx_worker_process_init //(ngx_process_cycle.c) worker初始化操作

	|-->for ( ;; ) //进入loop
		|-->ngx_process_events_and_timers //(ngx_event.c) //nginx的数据处理，其函数见下面的函数说明


|-->ngx_conf_handler //(ngx_conf_file.c) 配置文件的处理函数,根据配置文件中不同字段调用不同的处理函数
	|-->name = cf->args->elts
	|-->for (i = 0; cf->cycle->modules[i]; i++)
		|-->cmd = cf->cycle->modules[i]->commands //获取所有modules模块的cmd命令
		|-->if (cmd == NULL)
			|-->continue
			
		|-->for ( /* void */ ; cmd->name.len; cmd++)
			|-->if (name->len != cmd->name.len)
				|-->continue
				
			|-->if (ngx_strcmp(name->data, cmd->name.data) != 0)
				|-->continue
				
			|-->found = 1
			
			|-->if (cf->cycle->modules[i]->type != NGX_CONF_MODULE && cf->cycle->modules[i]->type != cf->module_type)
				|-->continue
	
			|-->if (!(cmd->type & cf->cmd_type))
				|-->continue
				
			|-->if ((cmd->type & NGX_CONF_BLOCK) && last != NGX_CONF_BLOCK_START)
				|-->return NGX_ERROR
				
			|-->cmd->set(cf, cmd, conf) //调用cmd中的set回调函数
				|-->case ngx_http_commands: //http的cmd
					|-->ngx_http_block // 主要是解析http相关的配置文件和设置accpet的回调函数

				|-->case ngx_http_core_commands: 
					|-->case "server":
						|-->ngx_http_core_server //配置文件中server字段的处理函数

					|-->case "listen":
						|-->ngx_http_core_listen //(ngx_http_core_module.c)

|-->ngx_http_block //(ngx_http.c)
	|-->ngx_http_max_module = ngx_count_modules //获取模块中type为NGX_HTTP_MODULE的个数
	|-->ctx->main_conf = ngx_pcalloc //预分配ngx_http_max_module个void型的指针数据
	|-->ctx->srv_conf = ngx_pcalloc //预分配ngx_http_max_module个void型的指针数据
	|-->ctx->loc_conf = ngx_pcalloc 
	
	|-->for (m = 0; cf->cycle->modules[m]; m++) //进行轮训
		|-->if (cf->cycle->modules[m]->type != NGX_HTTP_MODULE)
			|-->continue
			
		|-->module = cf->cycle->modules[m]->ctx
		|-->mi = cf->cycle->modules[m]->ctx_index
		
		|-->if (module->create_main_conf)
			|-->ctx->main_conf[mi] = module->create_main_conf() //调用回调函数
				|-->case ngx_http_core_module:
					|-->ngx_http_core_create_main_conf //(ngx_http_core_module.c)
					
				|-->case ngx_http_upstream_module:
					|-->ngx_http_upstream_create_main_conf //(ngx_http_upstream.c)
					
			
		|-->if (module->create_srv_conf)
			|-->ctx->srv_conf[mi] = module->create_srv_conf //调用回调函数
				|-->case ngx_http_core_module:
					|-->ngx_http_core_create_srv_conf //(ngx_http_core_module.c)
						|-->
			
		|-->if (module->create_loc_conf)
			|-->ctx->loc_conf[mi] = module->create_loc_conf //调用回调函数
			
	|-->for (m = 0; cf->cycle->modules[m]; m++) //进行轮训
		|-->if (cf->cycle->modules[m]->type != NGX_HTTP_MODULE)
			|-->continue
			
		|-->module = cf->cycle->modules[m]->ctx
		
		|-->if (module->preconfiguration)
			|-->module->preconfiguration //调用回调函数
			
	|-->ngx_conf_parse //解析文件内容
	
	|-->for (m = 0; cf->cycle->modules[m]; m++)
		|-->if (cf->cycle->modules[m]->type != NGX_HTTP_MODULE)
			|-->continue
			
		|-->module = cf->cycle->modules[m]->ctx
		
		|-->if (module->init_main_conf)
			|-->module->init_main_conf //调用回调函数
				|-->case ngx_http_upstream_module:
					|-->ngx_http_upstream_init_main_conf //(ngx_http_upstream.c)
						|-->for (i = 0; i < umcf->upstreams.nelts; i++)
							|-->init() //调用init初始化函数，默认情况下为 ngx_http_upstream_init_round_robin
								|-->ngx_http_upstream_init_round_robin //(ngx_http_upstream_round_robin.c)
									|-->
			
		|-->ngx_http_merge_servers //
		
	|-->for (s = 0; s < cmcf->servers.nelts; s++)
		|-->ngx_http_init_locations //()
		
		|-->ngx_http_init_static_location_trees //()
		
	|-->ngx_http_init_phases //
	
	|-->ngx_http_init_headers_in_hash //
	
	|-->for (m = 0; cf->cycle->modules[m]; m++)
		|-->if (cf->cycle->modules[m]->type != NGX_HTTP_MODULE)
			|-->continue
			
		|-->module = cf->cycle->modules[m]->ctx
		
		|-->if (module->postconfiguration)
			|-->module->postconfiguration //
			
	|-->ngx_http_variables_init_vars //()
	
	|-->ngx_http_init_phase_handlers //()
		
	|-->ngx_http_optimize_servers //(ngx_http.c)
		|-->ngx_http_init_listening //(ngx_http.c)
			|-->ngx_http_add_listening //(ngx_http.c)
				|-->ls->handler = ngx_http_init_connection //设置回调函数, 用于accept处理


|-->ngx_http_core_server //(ngx_http_core_module.c) 配置文件中server字段的解析
	|-->for (i = 0; cf->cycle->modules[i]; i++)
		|-->if (cf->cycle->modules[i]->type != NGX_HTTP_MODULE)
			|-->continue

		|-->module = cf->cycle->modules[i]->ctx
		
		|-->if (module->create_srv_conf) 
			|-->mconf = module->create_srv_conf(cf) //回调函数
				|-->case ngx_http_core_module:
					|-->ngx_http_core_create_srv_conf //(ngx_http_core_module.c)
						|-->ngx_array_init //

		|-->if (module->create_loc_conf)
			|-->mconf = module->create_loc_conf(cf) //回调函数
				|-->ngx_http_core_create_loc_conf //(ngx_http_core_module.c)

		|-->rv = ngx_conf_parse(cf, NULL) //对数据进行解析
		
		|-->if (rv == NGX_CONF_OK && !cscf->listen)
			|-->ngx_sock_ntop //(ngx_inet.c)
			|-->ngx_http_add_listen //(ngx_http.c)
				|-->ngx_http_add_addresses //(ngx_http.c)
					|-->ngx_http_add_server //(ngx_http.c)
					|-->ngx_http_add_address //(ngx_http.c)
						|-->ngx_http_add_server //(ngx_http.c)

	|-->for (i = 0; cf->cycle->modules[i]; i++)
		|-->if (cf->cycle->modules[i]->type != NGX_HTTP_MODULE)
			|-->continue;

		|-->module = cf->cycle->modules[i]->ctx //
					
|-->ngx_worker_process_init //(ngx_process_cycle.c) worker的初始化函数，用于初始化绑定系统调用关系(epoll)
	|-->ccf = (ngx_core_conf_t *) ngx_get_conf(cycle->conf_ctx, ngx_core_module)
	|-->for (i = 0; cycle->modules[i]; i++) 
		|-->if (cycle->modules[i]->init_process)
			|-->cycle->modules[i]->init_process(cycle) //回调函数
				|-->case ngx_thread_pool_module: //线程池模块
					|-->ngx_thread_pool_init_worker //(ngx_thread_pool.c)
				
				|-->case ngx_event_core_module: //event模块
					|-->ngx_event_process_init //(ngx_event.c) event初始化函数,具体的实现见下面的函数分析

	|-->ngx_add_channel_event(cycle, ngx_channel, NGX_READ_EVENT, ngx_channel_handler)
	

|-->ngx_process_events_and_timers //(ngx_event.c) //nginx的真正执行所在，等待数据的到来并进行相应的处理
	|-->if (ngx_use_accept_mutex) //是否使用accept锁, 默认情况下是不会使用锁的
		|-->if (ngx_accept_disabled > 0)
			|-->ngx_accept_disabled--
		
		|-->else //ngx_accept_disabled <= 0的情况
			|-->if(ngx_trylock_accept_mutex == NGX_ERROR ) //获取accept_mutex锁
				|-->return;

			|-->if (ngx_accept_mutex_held) //
				|-->ngx_disable_accept_events //(ngx_event_accept.c)
					|-->for (i = 0; i < cycle->listening.nelts; i++)
						|-->ngx_del_event(c->read, NGX_READ_EVENT, NGX_DISABLE_EVENT) //

				|-->ngx_accept_mutex_held = 0;

			|-->flags |= NGX_POST_EVENTS //对falg进行与处理,后面的步骤需要
			
	|-->ngx_process_events //(ngx_event.h)
		|-->ngx_event_actions.process_events //使用回调函数
			|-->ngx_epoll_process_events //(ngx_epoll_module.c) 具体的事件处理, 其内部处理流程常见下面的函数梳理
			
	|-->ngx_event_process_posted(cycle, &ngx_posted_accept_events)//处理在process_events中插入的数据,其处理流程见下面的分析
	
	|-->if (ngx_accept_mutex_held)
		|-->ngx_shmtx_unlock(&ngx_accept_mutex)
		
	|-->ngx_event_process_posted(cycle, &ngx_posted_events) //处理插入链表中的数据	

	
|-->ngx_epoll_process_events //(ngx_epoll_module.c) 具体的事件处理, 其内部处理流程常见下面的函数梳理
	|-->events = epoll_wait(ep, event_list, (int) nevents, timer) //等待数据的到来
	|-->for (i = 0; i < events; i++)
		|-->if ((revents & EPOLLIN) && rev->active)
			|-->rev->available = 1 //在后面的rcv->handler函数中需要检查该变量
			|--> rev->ready = 1
			|-->if (flags & NGX_POST_EVENTS)
				|-->queue = rev->accept ? &ngx_posted_accept_events : &ngx_posted_events
				|-->ngx_post_event(rev, queue) //见数据插入链表中,在外部进行处理
				
			|-->else
				|-->rev->handler //(ngx_epoll_module.c)该回调函数在不同阶段被赋予不同的处理函数
					|-->case ngx_event_accept //(ngx_event_accept.c)从listen状态接收到的新连接socket，准备accept
															
					|-->case ngx_http_wait_request_handler //(ngx_http_request.c) accept后的socket数据处理
							
					|-->case ngx_http_process_request_line //(ngx_http_request.c) 处理数据行

		|-->wev = c->write
		|-->if ((revents & EPOLLOUT) && wev->active)
			|-->wev->ready = 1
			|-->if (flags & NGX_POST_EVENTS)
				|-->ngx_post_event(wev, &ngx_posted_events) //见数据插入链表,在外部进行处理
				
			|-->else
				|-->wev->handler //处理可写事件

|-->ngx_event_process_posted //(ngx_event_posted.c) 具体的事件处理, 其内部处理流程常见下面的函数梳理
	|-->while (!ngx_queue_empty(posted)) //根据传入的queue链表进行循环处理(如果其内部不为空的话)
		|-->ngx_queue_head(posted)//获取head头节点
		|-->ngx_queue_data(q, ngx_event_t, queue) //获取当前节点
		|-->ngx_delete_posted_event(ev) //将该节点从链表中删除
		|-->ev->handler(ev) //执行回调函数, 该回调函数就是ngx_post_event中加入的数据
			|-->switch(posted)
				|-->case "ngx_posted_accept_events": //处理可读事件
					|-->case ngx_event_accept //(ngx_event_accept.c)从listen状态接收到的新连接socket，准备accept

                    |-->case ngx_http_wait_request_handler //(ngx_http_request.c) accept后的socket数据处理

                    |-->case ngx_http_process_request_line //(ngx_http_request.c) 处理数据行

				|-->case "ngx_posted_events": //处理可写事件


|-->ngx_trylock_accept_mutex //(ngx_event_accept.c) 获取accept_mutex锁
	|-->if (ngx_shmtx_trylock(&ngx_accept_mutex)) //尝试获取accept锁,如果获取到进入该分支
		|-->if (ngx_accept_mutex_held && ngx_accept_events == 0)
			|-->return OK

		|-->ngx_enable_accept_events //(ngx_event_accept.c)
			|-->for (i = 0; i < cycle->listening.nelts; i++)
				|-->c = ls[i].connection
				|-->if (c == NULL || c->read->active)
					continue
					
				|-->ngx_add_event(c->read, NGX_READ_EVENT, 0) //函数的实现参见函数分析说明
		
		|-->ngx_accept_events = 0
		|-->ngx_accept_mutex_held = 1
		|-->return NGX_OK

	|-->if (ngx_accept_mutex_held)
		|-->ngx_disable_accept_events
		|-->ngx_accept_mutex_held = 0

	|-->return NGX_OK

|-->ngx_epoll_eventfd_handler //(ngx_epoll_module.c)
	|-->epoll_ctl
	
|-->ngx_epoll_add_connection //(ngx_epoll_module.c)

|-->ngx_epoll_del_connection //

|-->ngx_epoll_del_event //

|-->ngx_event_core_init_conf //(ngx_event.c)

|-->ngx_conf_parse //(ngx_conf_file.c) 参数解析函数，用于解析nginx的配置文件及传入参数
	|-->ngx_conf_handler //(ngx_conf_file.c)
		|-->ngx_events_block //(ngx_event.c)
			|-->for (i = 0; cf->cycle->modules[i]; i++)
				|-->if (cf->cycle->modules[i]->type != NGX_EVENT_MODULE)
					|-->continue
		
				|-->m = cf->cycle->modules[i]->ctx
				|-->if (m->create_conf)
					|-->m->create_conf //()
		
			|-->ngx_conf_parse//
		
			|-->for (i = 0; cf->cycle->modules[i]; i++)
				|-->if (cf->cycle->modules[i]->type != NGX_EVENT_MODULE)
					|-->continue
		
				|-->m = cf->cycle->modules[i]->ctx
				|-->if (m->init_conf)
					|-->m->init_conf //(ngx_event.c)
		

|-->ngx_event_process_init //(ngx_event.c) event模块的初始化函数,根据不同的分类进行子模块的初始化工作和一些绑定关系的设置
	|-->if(ccf->master && ccf->worker_processes > 1 && ecf->accept_mutex) //ecf->accept_mutex默认为0不会进入该分支
		|-->ngx_use_accept_mutex = 1
		|-->ngx_accept_mutex_held = 0
		|-->ngx_accept_mutex_delay = ecf->accept_mutex_delay
	|-->else //默认配置下进入该分支
		|-->ngx_use_accept_mutex = 0 //默认情况下该值为0,在后面需要用到
	
	|-->ngx_queue_init(&ngx_posted_accept_events) //初始化链表,在后续的处理中需要用到,用来处理read事件
	|-->ngx_queue_init(&ngx_posted_events) //初始化链表,用来处理write事件
	|-->for (m = 0; cycle->modules[m]; m++)
		|-->if (cycle->modules[m]->type != NGX_EVENT_MODULE)
			|-->continue

		|-->if (cycle->modules[m]->ctx_index != ecf->use)
			|-->continue

		|-->module = cycle->modules[m]->ctx
		|-->module->actions.init //(ngx_event.c) 调用回调函数
			|-->ngx_epoll_init //(ngx_epoll_module.c) 调用epoll模块的init回调函, 具体实现参见函数说明

	|-->cycle->connections = ngx_alloc //预分配worker_connections个ngx_connection_t结构体空间
	|-->c = cycle->connections
	|-->cycle->read_events = ngx_alloc //预分配worker_connections个ngx_connection_t结构体空间
	|-->rev = cycle->read_events
	|-->for (i = 0; i < cycle->connection_n; i++)
		|-->rev[i].closed = 1
		|-->rev[i].instance = 1
	
	|-->cycle->write_events = ngx_alloc //预分配worker_connections个ngx_connection_t结构体空间
	|-->wev = cycle->write_events
	|-->for (i = 0; i < cycle->connection_n; i++)
		|-->wev[i].closed = 1

	|-->next = NULL
	|-->i = cycle->connection_n 
	|-->do 
		|-->i--
		|-->c[i].data = next
		|-->c[i].read = &cycle->read_events[i]
		|-->c[i].write = &cycle->write_events[i]
		|-->c[i].fd = (ngx_socket_t) -1
		|-->next = &c[i]
	|-->while(i)//对connections进行初始化,倒序初始化可以避免next初始化需要多写一行代码,写法很精妙 

	|-->cycle->free_connections = next //对free_connections进行初始化, 见用于ngx_get_connection获取空闲的空间
	|-->cycle->free_connection_n = cycle->connection_n 
					
	|-->for (i = 0; i < cycle->listening.nelts; i++)
		|-->if (ls[i].reuseport && ls[i].worker != ngx_worker) //是否开启SO_REUSEPORT功能,该功能需要kernel 3.9版本
			|-->continue; //如果设置了该功能kernel会为每个listen分配独立的hansh table,不再需要锁

		|-->c = ngx_get_connection(ls[i].fd, cycle->log) //(ngx_connection.c) 从链表中获取指针
		|-->rev->accept = 1 //该值用于判断recv到底是有那个链表, ngx_posted_accept_events, ngx_posted_events
		|-->switch(c->type) //设置rev的处理函数,根据协议类型选择(tcp, udp)
			|-->case SOCK_STREAM:
				|-->rev->handler = ngx_event_accept //tcp协议的初始化函数函数

			|-->default:
				|-->rev->handler = ngx_event_recvmsg //udp协议的初始化函数 

		|-->if (ls[i].reuseport) //是否开启SO_REUSEPORT
			|-->ngx_add_event(rev, NGX_READ_EVENT, 0)

		|-->if (ngx_use_accept_mutex)
			|-->continue;

		|-->if ((ngx_event_flags & NGX_USE_EPOLL_EVENT) && ccf->worker_processes > 1) 
			|-->ngx_add_event(rev, NGX_READ_EVENT, NGX_EXCLUSIVE_EVENT) //如果开启了NGX_HAVE_EPOLLEXCLUSIVE宏则进行设置 
			|-->continue //设置后直接跳过不再进入下一步设置,避免重复添加event事件 

		|-->ngx_add_event(rev, NGX_READ_EVENT, 0)//最终调用epoll_ctl加入相应的事件监听, 其实现参见函数说明

|-->ngx_get_connection //(ngx_connection.c) 从链表中获取指定的指针
	|-->c = ngx_cycle->free_connections //从free_connections链表获取
	|-->if (c == NULL) //如果free_connections链表为空
		|-->ngx_drain_connections //(ngx_connection.c)
			|-->for (i = 0; i < n; i++)
				|-->if (ngx_queue_empty(&cycle->reusable_connections_queue))
					|-->break;

				|-->q = ngx_queue_last(&cycle->reusable_connections_queue)
				|-->c = ngx_queue_data(q, ngx_connection_t, queue) //获取节点
				|-->c->close = 1
				|-->c->read->handler(c->read)

		|-->c = ngx_cycle->free_connections //再次进行赋值

	|-->if (c == NULL) //再次进行判断,如果依然为空则返回null
		|-->return NULL

	|-->ngx_cycle->free_connections = c->data //指向下一个节点
	|-->ngx_cycle->free_connection_n-- //对剩余节点数做减一处理
	|-->rev = c->read //保存read事件链表地址
	|-->wev = c->write //保存write事件链表地址
	|-->ngx_memzero(c, sizeof(ngx_connection_t)) //清空该结构体指针的空间
	|-->c->read = rev //重新赋值
	|-->c->write = wev //重新赋值
	|-->c->fd = s //将传入的socket句柄赋值给fd
	|-->c->log = log //将传入的log指针赋值给log
	|-->instance = rev->instance //
	|-->清空rev, wev指针
	|-->将rev, wev的instance 设置为 !instance
	|-->将rev, wev的data 设置为c
	|-->wev->write = 1
	|-->return c //返回一个connections指针


|-->ngx_event_accept //(ngx_event_accept.c)处理accept事件,并设置下一阶段的handler处理函数
	|-->c->recv = ngx_recv //设置回调函数绑定
	|-->c->send = ngx_send //设置回调函数绑定
	|-->do{
		|-->s = accept4/accpet //接收新连接的socket 
		|-->c = ngx_get_connection(s, ev->log) //获取空闲的connection节点
		|-->ls->handler //(ngx_event_accept.c)
			|-->ngx_http_init_connection //(ngx_http_request.c)
				|-->rev->handler = ngx_http_wait_request_handler // 设置可读回调函数	
				|-->c->write->handler = ngx_http_empty_handler // 设置可写的回调函数
				|-->if (rev->ready) //可读
					|-->rev->handler //(ngx_event_accept.c) 执行回调函数 
						|-->ngx_http_wait_request_handler //如果上面有可读事件则调用该函数

					|-->return //退出函数

				|-->ngx_add_timer(rev, c->listening->post_accept_timeout) //
				|-->ngx_reusable_connection(c, 1) //将c插入到reuse链表中,达到重复利用
				|-->ngx_handle_read_event(rev, 0) //(ngx_event.c) 添加到可读事件中
					|-->if (ngx_event_flags & NGX_USE_CLEAR_EVENT) //epoll会进入到该分支,在epoll_init你们进行设置
						|-->if (!rev->active && !rev->ready)
							|-->ngx_add_event(rev, NGX_READ_EVENT, NGX_CLEAR_EVENT) //添加事件

	|-->while(ev->available)//do while循环


|-->ngx_http_wait_request_handler //(ngx_http_request.c) accpet后下一阶段的数据处理函数
	|-->n = c->recv(c, b->last, size) //接收数据
		|-->ngx_recv //(ngx_event.h)
			|-->ngx_io.recv //(ngx_event.h) 在epoll_init里面将ngx_io设置为 ngx_os_io
				|-->ngx_unix_recv //(ngx_recv.c) 使用recv接收数据
				
	|-->ngx_reusable_connection(c, 0) //
	|-->rev->handler = ngx_http_process_request_line //设置新的回调函数，进入下一个状态
	|-->ngx_http_process_request_line //(ngx_http_request.c)
		|-->if (rev->timedout) //如果超时
			|-->c->timedout = 1
			|-->ngx_http_close_request(r, NGX_HTTP_REQUEST_TIME_OUT)
			|-->return

		|-->rc = NGX_AGAIN
		|-->for(;;)//循环接收处理数据
			|-->if (rc == NGX_AGAIN) //第一次进入时会进入该分支
				|-->ngx_http_read_request_header //(ngx_http_request.c)
					|-->if (rev->ready) //如果已经准备好,则直接接收处理
						|-->n = c->recv //接收处理,参考上面的流程分析
						|-->return n;

			|-->ngx_http_parse_request_line //(ngx_http_parse.c) 对接收到的数据进行解析
			|-->if (rc == NGX_OK) //如果解析正确
				|-->c->log->action = "reading client request headers"
				|-->rev->handler = ngx_http_process_request_headers //
				|-->ngx_http_process_request_headers //(ngx_http_request.c)
					|-->if (rev->timedout)
						|-->c->timedout = 1
						|-->ngx_http_close_request(r, NGX_HTTP_REQUEST_TIME_OUT);
						|-->return;

					|-->

				|-->return;

			|-->if (rc != NGX_AGAIN) //不等于初始化
				|-->ngx_http_finalize_request //(ngx_http_request.c)根据解析的返回值惊喜错误码处理
					|-->if (rc >= NGX_HTTP_SPECIAL_RESPONSE)
						|-->ngx_http_special_response_handler //(ngx_http_special_response.c)
							|-->ngx_http_send_error_page //(ngx_http_special_response.c)
								|-->ngx_http_send_special_response //(ngx_http_special_response.c)
						
							|-->ngx_http_send_special_response //(ngx_http_special_response.c)

				|-->return 


|-->ngx_reusable_connection //(ngx_connection.c) reusable_connection链表的处理
	|-->if (c->reusable)
		|-->ngx_queue_remove(&c->queue)
		|-->ngx_cycle->reusable_connections_n--

	|-->c->reusable = reusable
	|-->if (reusable)
		|-->ngx_queue_insert_head(
            (ngx_queue_t *) &ngx_cycle->reusable_connections_queue, &c->queue)
		|-->ngx_cycle->reusable_connections_n++


|-->ngx_epoll_init //(ngx_epoll_module.c) 调用epoll模块的初始化函数
	|-->ngx_event_get_conf(cycle->conf_ctx, ngx_epoll_module) //(ngx_event.h) 关联ngx_epoll_module模块
	
	|-->if (ep == -1) //第一次进入时ep=-1，创建epoll后该值将不等于-1
		|-->ep = epoll_create(cycle->connection_n / 2) //创建epoll
		
		|-->ngx_epoll_notify_init //(ngx_epoll_module.c) //(ngx_epoll_module.c)
			|-->notify_fd = eventfd(0, 0) //创建eventfd，用于通知消息
			|-->notify_event.handler = ngx_epoll_notify_handler //设置handler回调函数
			|-->notify_event.active = 1
			|-->notify_conn.fd = notify_fd
			|-->ee.events = EPOLLIN|EPOLLET
			|-->epoll_ctl(ep, EPOLL_CTL_ADD, notify_fd, &ee) //将notify_fd加入到epoll队列中
	
		|-->ngx_epoll_aio_init //(ngx_epoll_module.c) //默认不调用该函数，因为NGX_HAVE_FILE_AIO宏未定义
		
		|-->ngx_epoll_test_rdhup //(ngx_epoll_module.c)
		
		|-->ngx_io = ngx_os_io //设置全局变量，用于io操作(socket接收，发送等)
		|-->ngx_event_actions = ngx_epoll_module_ctx.actions //设置全局变量，回调函数设置，后面需要用到(按模块功能划分)
		|-->ngx_event_flags = NGX_USE_CLEAR_EVENT //在可读事件添加时需要用到这个flag变量
		

|-->ngx_add_event //(ngx_event.h) 事件添加处理
	|-->ngx_event_actions.add //使用ngx_event_actions的add回调函数
		|-->ngx_epoll_add_event //(ngx_epoll_module.c)
			|-->if (e->active) //根据active来设置op操作, 是EPOLL_CTL_MOD还是EPOLL_CTL_ADD
				|-->op = EPOLL_CTL_MOD //如果该值被设置说明已经添加了,需要将其设置为modify,以免重复添加
			|-->else //active = 0
				|-->op = EPOLL_CTL_ADD //说明该fd是第一次加入,将其设置add操作

			|-->epoll_ctl //添加事件
			|-->ev->active = 1 //设置变量,以判断后续加入时是否为第一次加入


|-->ngx_http_file_cache_reopen //

|-->ngx_http_upstream_init_request //()
|-->ngx_http_upstream_cache //

|-->ngx_http_file_cache_open //(ngx_http_file_cache.c)
	|-->ngx_http_file_cache_read //(ngx_http_file_cache.c)
		|-->ngx_http_file_cache_aio_read //(ngx_http_file_cache.c)
			|-->ngx_http_cache_thread_handler //(ngx_thread_pool.c)
				|-->task->event.data = r
				|-->task->event.handler = ngx_http_cache_thread_event_handler
				|-->ngx_thread_task_post //(ngx_thread_pool.c)
					|-->task->event.active = 1
					|-->task->id = ngx_thread_pool_task_id++
					|-->task->next = NULL
					|-->ngx_thread_cond_signal(&tp->cond, tp->log) //发送条件变量
					|-->*tp->queue.last = task
					|-->tp->queue.last = &task->next
					|-->tp->waiting++
					
			|-->ngx_read_file 

		
|-->ngx_http_upstream_server //() NGX_HTTP_MODULE

|-->ngx_thread_pool_init_worker //(ngx_thread_pool.c) 线程池初始化
	|-->ngx_thread_pool_queue_init(&ngx_thread_pool_done) //初始化ngx_thread_pool_done
	
	|-->for (i = 0; i < tcf->pools.nelts; i++) //根据定义的线程池个数进行初始化
		|-->ngx_thread_pool_queue_init(&tp->queue) //
		|-->ngx_thread_mutex_create(&tp->mtx, log) //
		|-->ngx_thread_cond_create(&tp->cond, log) //
		|-->ngx_thread_pool_init //(ngx_thread_pool.c)
			|-->for (n = 0; n < tp->threads; n++) //当前线程池内的线程个数
				|-->pthread_create(&tid, &attr, ngx_thread_pool_cycle, tp) //创建运行线程 ngx_thread_pool_cycle
				

|-->ngx_thread_pool_cycle //(ngx_thread_pool.c) 线程池的工作线程
	|-->for ( ;; )
		|-->ngx_thread_mutex_lock(&tp->mtx, tp->log) 
		|-->tp->waiting--
		|-->while (tp->queue.first == NULL)
			|-->ngx_thread_cond_wait(&tp->cond, &tp->mtx, tp->log) //等待条件变量
			
		|-->task->handler(task->ctx, tp->log) //调用函数
		|-->ngx_notify(ngx_thread_pool_handler) //
			|-->ngx_event_actions.notify //回调函数，实际执行的是 ngx_epoll_notify
				|-->ngx_epoll_notify //(ngx_epoll_module.c)
					|-->static uint64_t inc = 1
					|-->notify_event.data = handler //将 ngx_thread_pool_handler 赋值到 data
					|-->write(notify_fd, &inc, sizeof(uint64_t) //向notify_fd写入参数以触发其监听函数，监听函数为ngx_epoll_notify_init中初始化的 ngx_epoll_notify_handler

					
|-->ngx_epoll_notify_handler //(ngx_epoll_module.c) 线程池中通知处理函数
	|-->if (++ev->index == NGX_MAX_UINT32_VALUE)
		|-->n = read(notify_fd, &count, sizeof(uint64_t))
		|-->if ((size_t) n != sizeof(uint64_t))
			|-->ngx_log_error //打印错误log
			
	|-->handler = ev->data //对应ngx_thread_pool_cycle中传入的handler，即 ngx_thread_pool_handler
	|-->handler(ev) //实际调用的函数为 ngx_thread_pool_handler
		|-->ngx_thread_pool_handler //(ngx_thread_pool.c)
			|-->task = ngx_thread_pool_done.first 
			|-->ngx_thread_pool_done.first = NULL
			|-->ngx_thread_pool_done.last = &ngx_thread_pool_done.first
			
			|-->while (task)
				|-->event = &task->event
				|-->task = task->next
				|-->event->complete = 1
				|-->event->active = 0
				|-->event->handler //执行handler回调函数
				
						
|-->ngx_thread_pool_module //(ngx_thread_pool.c)

|-->ngx_thread_pool_add //(ngx_thread_pool.c)

|-->ngx_thread_pool_get //(ngx_thread_pool.c)

|-->ngx_thread_pool_exit_worker //(ngx_thread_pool.c)

|-->ngx_http_core_set_aio //(ngx_http_core_module.c)

ngx_log_debug0(NGX_LOG_DEBUG_HTTP, rev->log, 0,
                   "http process request line")


|-->ngx_http_filter_finalize_request //(ngx_http_special_response.c)

|-->ngx_thread_read //(ngx_files.c)
	|-->task->handler = ngx_thread_read_handler
	
|-->ngx_thread_write_chain_to_file //(ngx_files.c)
	|-->task->handler = ngx_thread_write_chain_to_file_handler
	
	
|-->ngx_linux_sendfile_thread //(ngx_linux_sendfile_chain.c)
	|-->task->handler = ngx_linux_sendfile_thread_handler

|-->ngx_close_accepted_connection //(ngx_event_accept.c)
	|-->ngx_free_connection //(ngx_connection.c)

|-->ngx_http_close_connection //(ngx_http_request.c) 关闭连接,用于释放connection节点
	|-->ngx_close_connection //(ngx_connection.c)
		|-->ngx_free_connection //(ngx_connection.c) //将要释放的指针插入free_connections的头部
			|-->c->data = ngx_cycle->free_connections 
			|-->ngx_cycle->free_connections = c
			|-->ngx_cycle->free_connection_n++

|-->ngx_http_upstream //(ngx_http_upstream.c) 配置文件中"upstream"字段处理函数
	|-->ngx_http_upstream_add //(ngx_http_upstream.c)
		|-->
	
	|-->ctx = ngx_pcalloc 
	|-->ctx->srv_conf = ngx_pcalloc
	|-->ctx->loc_conf = ngx_pcalloc
	|-->for (m = 0; cf->cycle->modules[m]; m++)
		|-->if (module->create_srv_conf)
			|-->module->create_srv_conf(cf)
				|-->
			
		|-->if (module->create_loc_conf)
			|-->mconf = module->create_loc_conf(cf)
			
	|-->ngx_conf_parse
	
|-->ngx_http_upstream_server //(ngx_http_upstream.c) 处理配置文件中"upstream"的子项里面的"server"
	|-->for (i = 2; i < cf->args->nelts; i++)
		|-->