|-----------------------重要数据结构-------------------------------------

|-->typedef struct ngx_module_s          ngx_module_t
|-->typedef struct ngx_conf_s            ngx_conf_t
|-->typedef struct ngx_cycle_s           ngx_cycle_t
|-->typedef struct ngx_pool_s            ngx_pool_t
|-->typedef struct ngx_chain_s           ngx_chain_t
|-->typedef struct ngx_log_s             ngx_log_t
|-->typedef struct ngx_open_file_s       ngx_open_file_t
|-->typedef struct ngx_command_s         ngx_command_t
|-->typedef struct ngx_file_s            ngx_file_t
|-->typedef struct ngx_event_s           ngx_event_t
|-->typedef struct ngx_event_aio_s       ngx_event_aio_t
|-->typedef struct ngx_connection_s      ngx_connection_t
|-->typedef struct ngx_thread_task_s     ngx_thread_task_t
|-->typedef struct ngx_ssl_s             ngx_ssl_t
|-->typedef struct ngx_ssl_connection_s  ngx_ssl_connection_t
|-->typedef struct ngx_udp_connection_s  ngx_udp_connection_t
|-->typedef u_char *(*ngx_log_handler_pt) (ngx_log_t *log, u_char *buf, size_t len)
|-->typedef void (*ngx_log_writer_pt) (ngx_log_t *log, ngx_uint_t level, u_char *buf, size_t len)
|-->#define NGX_ERROR_LOG_PATH  "logs/error.log"


|-->log文件操作数据结构体ngx_open_file_s //(ngx_conf_file.h)
	|-->struct ngx_open_file_s {
		ngx_fd_t              fd;
		ngx_str_t             name;

		void                (*flush)(ngx_open_file_t *file, ngx_log_t *log); //flush函数指针
		void                 *data;
	};


|-->log数据结构体ngx_log_s //(ngx_log.h)
	|-->struct ngx_log_s {
		ngx_uint_t           log_level;  
		ngx_open_file_t     *file;       

		ngx_atomic_uint_t    connection; 

		time_t               disk_full_time;

		ngx_log_handler_pt   handler; //函数指针 指针 
		void                *data;       

		ngx_log_writer_pt    writer;     
		void                *wdata;

		/*
		 * we declare "action" as "char *" because the actions are usually
		 * the static strings and in the "u_char *" case we have to override
		 * their types all the time
		 */ 

		char                *action;

		ngx_log_t           *next;
	};


|-->ngx_cycle数据结构体ngx_cycle_s //(ngx_cycle.h)
	|-->struct ngx_cycle_s {
		void                  ****conf_ctx;
		ngx_pool_t               *pool;

		ngx_log_t                *log;
		ngx_log_t                 new_log;

		ngx_uint_t                log_use_stderr;  /* unsigned  log_use_stderr:1; */

		ngx_connection_t        **files;
		ngx_connection_t         *free_connections;
		ngx_uint_t                free_connection_n;

		ngx_module_t            **modules;
		ngx_uint_t                modules_n;
		ngx_uint_t                modules_used;    /* unsigned  modules_used:1; */

		ngx_queue_t               reusable_connections_queue;
		ngx_uint_t                reusable_connections_n;

		ngx_array_t               listening;
		ngx_array_t               paths;

		ngx_array_t               config_dump;
		ngx_rbtree_t              config_dump_rbtree;
		ngx_rbtree_node_t         config_dump_sentinel;

		ngx_list_t                open_files;
		ngx_list_t                shared_memory;

		ngx_uint_t                connection_n;
		ngx_uint_t                files_n;
		ngx_connection_t         *connections;
		ngx_event_t              *read_events;
		ngx_event_t              *write_events;

		ngx_cycle_t              *old_cycle;

		ngx_str_t                 conf_file;
		ngx_str_t                 conf_param;
		ngx_str_t                 conf_prefix;
		ngx_str_t                 prefix;
		ngx_str_t                 lock_file;
		ngx_str_t                 hostname;
	};

|-->ngx_event_actions事件处理结构体(对应不同清空的执行动作) //(ngx_event.h)
	|-->typedef struct {
		ngx_int_t  (*add)(ngx_event_t *ev, ngx_int_t event, ngx_uint_t flags);
		ngx_int_t  (*del)(ngx_event_t *ev, ngx_int_t event, ngx_uint_t flags);

		ngx_int_t  (*enable)(ngx_event_t *ev, ngx_int_t event, ngx_uint_t flags);
		ngx_int_t  (*disable)(ngx_event_t *ev, ngx_int_t event, ngx_uint_t flags);

		ngx_int_t  (*add_conn)(ngx_connection_t *c);
		ngx_int_t  (*del_conn)(ngx_connection_t *c, ngx_uint_t flags);

		ngx_int_t  (*notify)(ngx_event_handler_pt handler);

		ngx_int_t  (*process_events)(ngx_cycle_t *cycle, ngx_msec_t timer,
									 ngx_uint_t flags);

		ngx_int_t  (*init)(ngx_cycle_t *cycle, ngx_msec_t timer);
		void       (*done)(ngx_cycle_t *cycle);
	} ngx_event_actions_t; 

|-->ngx_event_module事件结构体(包含配置创建和初始化) //(ngx_event.h)
	|-->typedef struct {
		ngx_str_t              *name;        
			
		void                 *(*create_conf)(ngx_cycle_t *cycle);
		char                 *(*init_conf)(ngx_cycle_t *cycle, void *conf);

		ngx_event_actions_t     actions;     
	} ngx_event_module_t;
	
|-->ngx_module module结构体 //(ngx_module.h)
	|-->struct ngx_module_s {
		ngx_uint_t            ctx_index;
		ngx_uint_t            index;

		char                 *name;

		ngx_uint_t            spare0;
		ngx_uint_t            spare1;

		ngx_uint_t            version;
		const char           *signature;

		void                 *ctx;
		ngx_command_t        *commands;
		ngx_uint_t            type;

		ngx_int_t           (*init_master)(ngx_log_t *log);

		ngx_int_t           (*init_module)(ngx_cycle_t *cycle);

		ngx_int_t           (*init_process)(ngx_cycle_t *cycle);
		ngx_int_t           (*init_thread)(ngx_cycle_t *cycle);
		void                (*exit_thread)(ngx_cycle_t *cycle);
		void                (*exit_process)(ngx_cycle_t *cycle);

		void                (*exit_master)(ngx_cycle_t *cycle);

		uintptr_t             spare_hook0;
		uintptr_t             spare_hook1;
		uintptr_t             spare_hook2;
		uintptr_t             spare_hook3;
		uintptr_t             spare_hook4;
		uintptr_t             spare_hook5;
		uintptr_t             spare_hook6;
		uintptr_t             spare_hook7;
	};
	
|-->static ngx_event_module_t  ngx_epoll_module_ctx = {
    &epoll_name,
    ngx_epoll_create_conf,               /* create configuration */
    ngx_epoll_init_conf,                 /* init configuration */

    {
        ngx_epoll_add_event,             /* add an event */
        ngx_epoll_del_event,             /* delete an event */
        ngx_epoll_add_event,             /* enable an event */
        ngx_epoll_del_event,             /* disable an event */
        ngx_epoll_add_connection,        /* add an connection */
        ngx_epoll_del_connection,        /* delete an connection */
#if (NGX_HAVE_EVENTFD)
        ngx_epoll_notify,                /* trigger a notify */
#else
        NULL,                            /* trigger a notify */
#endif
        ngx_epoll_process_events,        /* process the events */
        ngx_epoll_init,                  /* init the events */
        ngx_epoll_done,                  /* done the events */
    }
};

#define NGX_CORE_MODULE      0x45524F43
#define NGX_EVENT_MODULE     0x544E5645

ngx_module_t  ngx_epoll_module = {
    NGX_MODULE_V1,
    &ngx_epoll_module_ctx,               /* module context */
    ngx_epoll_commands,                  /* module directives */
    NGX_EVENT_MODULE,                    /* module type */
    NULL,                                /* init master */
    NULL,                                /* init module */
    NULL,                                /* init process */
    NULL,                                /* init thread */
    NULL,                                /* exit thread */
    NULL,                                /* exit process */
    NULL,                                /* exit master */
    NGX_MODULE_V1_PADDING
};

ngx_module_t  ngx_event_core_module = {
    NGX_MODULE_V1,
    &ngx_event_core_module_ctx,            /* module context */
    ngx_event_core_commands,               /* module directives */
    NGX_EVENT_MODULE,                      /* module type */
    NULL,                                  /* init master */
    ngx_event_module_init,                 /* init module */
    ngx_event_process_init,                /* init process */
    NULL,                                  /* init thread */
    NULL,                                  /* exit thread */
    NULL,                                  /* exit process */
    NULL,                                  /* exit master */
    NGX_MODULE_V1_PADDING
}; //(ngx_event.c) evnet事件的核心定义，其包含epoll结构体的关联

static ngx_event_module_t  ngx_event_core_module_ctx = {
    &event_core_name,
    ngx_event_core_create_conf,            /* create configuration */
    ngx_event_core_init_conf,              /* init configuration */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL }
};//(ngx_event.c)

static ngx_command_t  ngx_http_commands[] = {
    { ngx_string("http"),
      NGX_MAIN_CONF|NGX_CONF_BLOCK|NGX_CONF_NOARGS,
      ngx_http_block,
      0,
      0,
      NULL },

      ngx_null_command
}; //http模块解析指令

static ngx_core_module_t  ngx_http_module_ctx = {
    ngx_string("http"),
    NULL,
    NULL
};

ngx_module_t  ngx_http_module = {
    NGX_MODULE_V1,
    &ngx_http_module_ctx,                  /* module context */
    ngx_http_commands,                     /* module directives */
    NGX_CORE_MODULE,                       /* module type */
    NULL,                                  /* init master */
    NULL,                                  /* init module */
    NULL,                                  /* init process */
    NULL,                                  /* init thread */
    NULL,                                  /* exit thread */
    NULL,                                  /* exit process */
    NULL,                                  /* exit master */
    NGX_MODULE_V1_PADDING
};


|-->command指令集 //(ngx_conf_file.h)
	|-->struct ngx_command_s {
	    ngx_str_t             name;
	    ngx_uint_t            type;
	    char               *(*set)(ngx_conf_t *cf, ngx_command_t *cmd, void *conf);
	    ngx_uint_t            conf;
	    ngx_uint_t            offset;
	    void                 *post;
	};

ngx_module_t *ngx_modules[] = {
    &ngx_core_module,
    &ngx_errlog_module,
    &ngx_conf_module,
    &ngx_regex_module,
    &ngx_events_module,
    &ngx_event_core_module,
    &ngx_epoll_module,
    &ngx_http_module,
    &ngx_http_core_module,
    &ngx_http_log_module,
    &ngx_http_upstream_module,
    &ngx_http_static_module,
    &ngx_http_autoindex_module,
    &ngx_http_index_module,
    &ngx_http_mirror_module,
    &ngx_http_try_files_module,
    &ngx_http_auth_basic_module,
    &ngx_http_access_module,
    &ngx_http_limit_conn_module,
    &ngx_http_limit_req_module,
    &ngx_http_geo_module,
    &ngx_http_map_module,
    &ngx_http_split_clients_module,
    &ngx_http_referer_module,
    &ngx_http_rewrite_module,
    &ngx_http_proxy_module,
    &ngx_http_fastcgi_module,
    &ngx_http_uwsgi_module,
    &ngx_http_scgi_module,
    &ngx_http_memcached_module,
    &ngx_http_empty_gif_module,
    &ngx_http_browser_module,
    &ngx_http_upstream_hash_module,
	&ngx_http_upstream_ip_hash_module,
    &ngx_http_upstream_least_conn_module,
    &ngx_http_upstream_random_module,
    &ngx_http_upstream_keepalive_module,
    &ngx_http_upstream_zone_module,
    &ngx_http_write_filter_module,
    &ngx_http_header_filter_module,
    &ngx_http_chunked_filter_module,
    &ngx_http_range_header_filter_module,
    &ngx_http_gzip_filter_module,
    &ngx_http_postpone_filter_module,
    &ngx_http_ssi_filter_module,
    &ngx_http_charset_filter_module,
    &ngx_http_userid_filter_module,
    &ngx_http_headers_filter_module,
    &ngx_http_copy_filter_module,
    &ngx_http_range_body_filter_module,
    &ngx_http_not_modified_filter_module,
    NULL
}; //(objs/ngx_modules.c) 所有module的集合

|-->ngx_process_events_and_timers //(ngx_event.c) 处理不同的事件
	|-->ngx_trylock_accept_mutex //(ngx_event_accept.c)
		|-->ngx_shmtx_trylock //()
		|-->

	|-->ngx_process_events(cycle, timer, flags) //实际调用ngx_epoll_process_events函数开始处理
		|-->ngx_epoll_process_events //(ngx_epoll_module.c)
			|-->epoll_wait //(ngx_process_events.c)


|-->main //(nginx.c) nginx函数入口
	|-->ngx_max_sockets = -1 
	|-->ngx_time_init //
	|-->ngx_regex_init //默认NGX_PCRE为true
	|-->ngx_log_init //(ngx_log.c)
		|-->ngx_log.file = &ngx_log_file 
		|-->ngx_log.log_level = NGX_LOG_NOTICE //设置打印等级
		|-->name = (u_char *) NGX_ERROR_LOG_PATH //获取文件名称
		|-->ngx_log_file.fd = ngx_open_file(name, NGX_FILE_APPEND,
                                    NGX_FILE_CREATE_OR_OPEN,
                                    NGX_FILE_DEFAULT_ACCESS) //打开文件, 当文件不存在时创建文件
									
		|-->return &ngx_log //返回ngx_log的地址
		
	|-->ngx_memzero(&init_cycle, sizeof(ngx_cycle_t)) //清空init_cycle
	|-->init_cycle.log = log //将ngx_log的地址赋值给init_cycle.log
	|-->ngx_cycle = &init_cycle //
	
	|-->init_cycle.pool = ngx_create_pool //
	
	|-->ngx_process_options //
	
	|-->ngx_os_init //(ngx_posix_init.c)
		|-->ngx_inherited_nonblocking = 0 //设置变量
	
	|-->ngx_crc32_table_init //(ngx_crc32.c)
		|-->ngx_crc32_table_short //对该值进行初始化赋值
	
	|-->ngx_slab_sizes_init //(ngx_slab.c)
		|-->ngx_slab_max_size = ngx_pagesize / 2
		|-->ngx_slab_exact_size = ngx_pagesize / (8 * sizeof(uintptr_t))
	
	|-->ngx_add_inherited_sockets //(nginx.c)
		|-->ngx_array_init(&cycle->listening, cycle->pool, 10, sizeof(ngx_listening_t) //(ngx_array.h)
			|-->array->nelts = 0 
			|-->array->pool = pool
			|-->array->elts = ngx_palloc(pool, n * size) //对cycle->listening.elts进行分配，10个地址大小
		
		|-->ngx_inherited = 1 //赋值，后面的流程需要用到
		
		|-->ngx_set_inherited_sockets //(ngx_connection.c)
			|-->ls = cycle->listening.elts
			|-->for (i = 0; i < cycle->listening.nelts; i++) //进不去，nelts的值为0
				|-->
	
	|-->ngx_preinit_modules //(ngx_module.c)
		|-->for (i = 0; ngx_modules[i]; i++) //获取
			|-->ngx_modules[i]->index = i;
			|-->ngx_modules[i]->name = ngx_module_names[i];

		|-->ngx_modules_n = i //统计当前的module数量，用于后面的拷贝复制
		|-->ngx_max_module = ngx_modules_n + NGX_MAX_DYNAMIC_MODULES
	
	|-->ngx_init_cycle //(ngx_cycle.c)
		|-->ngx_array_init(&cycle->listening, pool, n, sizeof(ngx_listening_t) //初始化listening
		|-->ngx_memzero(cycle->listening.elts, n * sizeof(ngx_listening_t))
		|-->ngx_queue_init(&cycle->reusable_connections_queue) //对队列进行初始化
		|-->cycle->conf_ctx = ngx_pcalloc(pool, ngx_max_module * sizeof(void *)) //分配空间
		
		|-->ngx_cycle_modules //(ngx_module.c)
			|-->cycle->modules = ngx_pcalloc(cycle->pool, (ngx_max_module + 1) * sizeof(ngx_module_t *)) //分配空间
			|-->ngx_memcpy(cycle->modules, ngx_modules, ngx_modules_n * sizeof(ngx_module_t *)) //将全局module拷贝到cycle->modules
			|-->cycle->modules_n = ngx_modules_n //当前module的数量
		
		|-->for (i = 0; cycle->modules[i]; i++) //对modules进行轮训判断其type值
			|-->if (cycle->modules[i]->type != NGX_CORE_MODULE) //对modules进行轮训判断其type值
				|-->continue //只要type=NGX_CORE_MODULE的module
			
			|-->module = cycle->modules[i]->ctx //获取结构体中ngx_event_module_t成员, 本次分析以ngx_event_core_module_ctx为例子
			|-->if (module->create_conf) //如果create_conf回调函数存在则调用回调
				module->create_conf //调用关联模块的回调函数
					|-->case ngx_core_module:
						|-->ngx_core_module_create_conf //(nginx.c)
							|-->ccf->daemon = NGX_CONF_UNSET //初始化
							|-->ccf->master = NGX_CONF_UNSET //初始化
							|-->ccf->worker_processes = NGX_CONF_UNSET 
							
					|-->case ngx_regex_module:
						|-->ngx_regex_create_conf //(ngx_regex.c)
		
		|-->conf.args = ngx_array_create(pool, 10, sizeof(ngx_str_t)) 
		|-->conf.temp_pool = ngx_create_pool(NGX_CYCLE_POOL_SIZE, log)
		
		|-->conf.module_type = NGX_CORE_MODULE
		|-->conf.cmd_type = NGX_MAIN_CONF

		|-->ngx_conf_param //(ngx_conf_file.c)
			|-->param = &cf->cycle->conf_param
			|-->ngx_memzero(&b, sizeof(ngx_buf_t))//清空结构体b
			|-->ngx_memzero(&conf_file, sizeof(ngx_conf_file_t))
			|-->b.start = param->data
			|-->b.pos = param->data
			|-->b.last = param->data + param->len
			|-->b.end = b.last
			|-->b.temporary = 1
			|-->conf_file.file.fd = NGX_INVALID_FILE
			|-->conf_file.file.name.data = NULL
			|-->conf_file.line = 0
			|-->cf->conf_file = &conf_file
			|-->cf->conf_file->buffer = &b 
			|-->ngx_conf_parse(cf, NULL) //(ngx_conf_file.c) 对cf进行解析
			|-->cf->conf_file = NULL //
			
		|-->ngx_conf_parse //(ngx_conf_file.c)
			|-->if (filename) //filename是传入的第二个参数
				|-->fd = ngx_open_file(filename->data, NGX_FILE_RDONLY, NGX_FILE_OPEN, 0) //打开文件，实际调用的就是open函数, 返回fd
				|-->if(fd == NGX_INVALID_FILE)
					|-->return NGX_CONF_ERROR;
					
				|-->prev = cf->conf_file //使用prev将cf中的原始文件信息保存起来
				|-->cf->conf_file = &conf_file //使用一个新的变量
				
				|-->ngx_fd_info(fd, &cf->conf_file->file.info) //读取文件属性(实际调用的是fstat，读取文件的属性)
				|-->cf->conf_file->buffer = &buf //使用buf进行存储
				|-->buf.start = ngx_alloc(NGX_CONF_BUFFER, cf->log) //进行空间分配
				|-->buf.pos = buf.start
				|-->buf.last = buf.start
				|-->buf.end = buf.last + NGX_CONF_BUFFER //NGX_CONF_BUFFER = 4096, 指定偏移量
				|-->buf.temporary = 1
				|-->cf->conf_file->file.fd = fd //将fd进行赋值
				|-->cf->conf_file->file.name.len = filename->len
				|-->cf->conf_file->file.name.data = filename->data
				|-->cf->conf_file->file.offset = 0
				|-->cf->conf_file->file.log = cf->log
				|-->cf->conf_file->line = 1
				|-->type = parse_file //设置类型为文件解析
				
			|-->else if (cf->conf_file->file.fd != NGX_INVALID_FILE) //如果filename为空，但fd不为初始值
				|-->type = parse_block //设置为解析block
				
			|-->else //如果filename为空，且cf->conf_file->file.fd为NGX_INVALID_FILE
				|-->type = parse_param //设置为解析参数
				
			|-->for ( ;; )
				|-->rc = ngx_conf_read_token(cf) //(ngx_conf_file.c)
					|-->cf->args->nelts = 0
					|-->start = b->pos
					|-->start_line = cf->conf_file->line
					|-->file_size = ngx_file_size(&cf->conf_file->file.info) //获取文件大小
					
					|-->for ( ;; )
						|-->
						
				|-->ngx_conf_handler //(ngx_conf_file.c)
					|-->name = cf->args->elts
					
					|-->for (i = 0; cf->cycle->modules[i]; i++)
						|-->cmd = cf->cycle->modules[i]->commands //获取所有modules模块的cmd命令
						|-->if (cmd == NULL)
							|-->continue
							
						|-->for ( /* void */ ; cmd->name.len; cmd++)
							|-->if (name->len != cmd->name.len)
								|-->continue
								
							|-->if (ngx_strcmp(name->data, cmd->name.data) != 0)
								|-->continue
								
							|-->found = 1
							
							|-->if (cf->cycle->modules[i]->type != NGX_CONF_MODULE && cf->cycle->modules[i]->type != cf->module_type)
								|-->continue
					
							|-->if (!(cmd->type & cf->cmd_type))
								|-->continue
								
							|-->if ((cmd->type & NGX_CONF_BLOCK) && last != NGX_CONF_BLOCK_START)
								|-->return NGX_ERROR
								
							|-->

		|-->for (i = 0; cycle->modules[i]; i++) //对全局modules指针数组进行轮巡
			|-->if (cycle->modules[i]->type != NGX_CORE_MODULE)
				|-->continue //只要type=NGX_CORE_MODULE的module
				
			|-->module = cycle->modules[i]->ctx 
			|-->if (module->init_conf) //如果create_conf回调函数存在则调用回调
				|-->module->init_conf //调用各个关联模块的回调函数
					|-->case ngx_core_module:
						|-->ngx_core_module_init_conf //(ngx_event.c)
							|-->ngx_conf_init_value(ccf->daemon, 1)
							|-->ngx_conf_init_value(ccf->master, 1) //(ngx_conf_file.h)
								|-->if (conf == NGX_CONF_UNSET)
									|-->ccf->master = 1 //设置master的值为1，该值在后面用来判断ngx_process工作类型
									
							|-->ngx_conf_init_value(ccf->worker_processes, 1) //将worker_processes的值设置为1
							
					|-->case ngx_regex_module:
						|-->ngx_regex_init_conf //()
					
					|-->ngx_events_module:
						|-->ngx_event_init_conf //(ngx_event.c)
							|-->ngx_get_conf(cycle->conf_ctx, ngx_events_module) //(ngx_event.c)
								|-->return conf_ctx[module.index] //(ngx_conf_file.h)
			
		|-->ngx_open_listening_sockets //(ngx_connection.c)
		|-->if (!ngx_test_config)			
			|-->ngx_configure_listening_sockets //(ngx_connection.c)

		|-->ngx_init_modules //(ngx_module.c)
			|-->for (i = 0; cycle->modules[i]; i++)
				|-->if (cycle->modules[i]->init_module)
					|-->cycle->modules[i]->init_module(cycle)
						|-->case ngx_event_core_module: 
							|-->ngx_event_module_init //()
								|-->ngx_shmtx_create(&ngx_accept_mutex, (ngx_shmtx_sh_t *) shared, cycle->lock_file.data)
									|-->mtx->lock = &addr->lock; //addr=shared
									|-->sem_init(&mtx->sem, 1, 0)
		
	|-->ngx_os_status //(ngx_posix_init.c) //打印一些os的状态值
	
	|-->ccf = (ngx_core_conf_t *) ngx_get_conf(cycle->conf_ctx, ngx_core_module) //获取ngx_core_module中索引值的conf_ctx
	
	|-->if (ccf->master && ngx_process == NGX_PROCESS_SINGLE) //master的值在init中被设置为1，ngx_process原始默认为0 
		|-->ngx_process = NGX_PROCESS_MASTER //默认情况下会进入设置该状态

	|-->ngx_init_signals //(ngx_process.c) 
		|-->for (sig = signals; sig->signo != 0; sig++) //对signals数组进行遍历，并设置其signal信号执行函数
			|-->if (sig->handler) //如果设置了回调函数，则将其添加到回调函数中
				|-->sa.sa_sigaction = sig->handler
				|-->sa.sa_flags = SA_SIGINFO
			|-->else
				|-->sa.sa_handler = SIG_IGN
				
			|-->sigemptyset(&sa.sa_mask)
			|-->sigaction //设置信号执行函数
	
	|-->if (ngx_inherited) //在上面的流程中被设置
		|-->ngx_daemonized = 1 //设置daemon
	
	|-->ngx_create_pidfile //()
	
	|-->ngx_log_redirect_stderr //()
		
	|-->if (ngx_process == NGX_PROCESS_SINGLE) //默认不进入该状态
		|-->ngx_single_process_cycle
	
	|-->else //当ngx_process不等于NGX_PROCESS_SINGLE时进入该分支。默认进入该分支
		|-->ngx_master_process_cycle //(ngx_process_cycle.c)
			|-->ccf = (ngx_core_conf_t *) ngx_get_conf(cycle->conf_ctx, ngx_core_module) //获取conf_ctx[0]
			|-->ngx_start_worker_processes(cycle, ccf->worker_processes, NGX_PROCESS_RESPAWN) //(ngx_process_cycle.c) worker_processes的数值为1
				|-->for (i = 0; i < n; i++) //n为1
					|-->ngx_spawn_process(cycle, ngx_worker_process_cycle, (void *) (intptr_t) i, "worker process", type) //(ngx_process.c)	
						|-->ngx_process_slot = s
						|-->pid = fork()
						|-->switch (pid)
							|-->case -1://创建失败
								|-->NGX_INVALID_PID
								
							|-->case 0://子进程
								|-->ngx_parent = ngx_pid
								|-->ngx_pid = ngx_getpid()
								|-->proc(cycle, data) //执行传入的函数指针
									|-->ngx_worker_process_cycle //(ngx_process_cycle.c)
										|-->ngx_process = NGX_PROCESS_WORKER //将其设置为NGX_PROCESS_WORKER
										|-->ngx_worker = worker
										|-->ngx_worker_process_init //(ngx_process_cycle.c)
											|-->ccf = (ngx_core_conf_t *) ngx_get_conf(cycle->conf_ctx, ngx_core_module)
											|-->for (i = 0; cycle->modules[i]; i++) 
												|-->if (cycle->modules[i]->init_process)
													|-->cycle->modules[i]->init_process(cycle) //回调函数
														|-->case ngx_event_core_module:
															|-->ngx_event_process_init //(ngx_event.c)
																|-->ngx_queue_init(&ngx_posted_accept_events) //
																|-->ngx_queue_init(&ngx_posted_events) //
																|-->for (m = 0; cycle->modules[m]; m++)
																	|-->if (cycle->modules[m]->type != NGX_EVENT_MODULE)
																		|-->continue
															
																	|-->if (cycle->modules[m]->ctx_index != ecf->use)
																		|-->continue
															
																	|-->module = cycle->modules[m]->ctx
																	|-->module->actions.init //(ngx_event.c) 调用回调函数
																		|-->ngx_epoll_init //(ngx_epoll_module.c) 调用epoll模块的init回调函
																			|-->ngx_event_get_conf(cycle->conf_ctx, ngx_epoll_module) //(ngx_event.h) 关联ngx_epoll_module模块
																				|-->
																			
																			|-->if (ep == -1) //第一次进入时ep=-1，创建epoll后该值将不等于-1
																				|-->ep = epoll_create(cycle->connection_n / 2) //创建epoll
																				
																				|-->ngx_epoll_notify_init //(ngx_epoll_module.c) //(ngx_epoll_module.c)
																					|-->notify_fd = eventfd(0, 0) //创建eventfd，用于通知消息
																					|-->notify_event.handler = ngx_epoll_notify_handler //设置handler回调函数
																					|-->notify_event.active = 1
																					|-->notify_conn.fd = notify_fd
																					|-->ee.events = EPOLLIN|EPOLLET
																					|-->epoll_ctl(ep, EPOLL_CTL_ADD, notify_fd, &ee) //将notify_fd加入到epoll队列中
																			
																				|-->ngx_epoll_aio_init //(ngx_epoll_module.c) //默认不调用该函数，因为NGX_HAVE_FILE_AIO宏未定义
																				
																				|-->ngx_epoll_test_rdhup //(ngx_epoll_module.c)
																				
																				|-->ngx_event_actions = ngx_epoll_module_ctx.actions //设置全局变量，回调设置，后面会用到
																				
																|-->for (i = 0; i < cycle->listening.nelts; i++)
																	|-->if (ls[i].reuseport && ls[i].worker != ngx_worker) //是否开启SO_REUSEPORT功能,该功能需要内核支持,最低时kernel 3.9版本
																		|-->continue;

																	|-->c = ngx_get_connection(ls[i].fd, cycle->log) //(ngx_connection.c)

																|-->rev->handler = (c->type == SOCK_STREAM) ? ngx_event_accept : ngx_event_recvmsg //设置rev的处理函数,根据协议类型选择(tcp, udp)

																|-->if (ls[i].reuseport) //是否开启SO_REUSEPORT
																	|-->ngx_add_event(rev, NGX_READ_EVENT, 0)

																|-->if (ngx_use_accept_mutex)
																	|-->continue;

																|-->if ((ngx_event_flags & NGX_USE_EPOLL_EVENT) && ccf->worker_processes > 1) 
																	|-->ngx_add_event(rev, NGX_READ_EVENT, NGX_EXCLUSIVE_EVENT) 
																|-->ngx_add_event(rev, NGX_READ_EVENT, 0)

											|-->ngx_add_channel_event(cycle, ngx_channel, NGX_READ_EVENT, ngx_channel_handler)
											
										|-->for ( ;; ) //进入loop
											|-->ngx_process_events_and_timers //(ngx_event.c)
												|-->if (ngx_use_accept_mutex) //是否使用accept锁
													|-->if (ngx_accept_disabled > 0)
														|-->ngx_accept_disabled--
													
													|-->else
														|-->ngx_trylock_accept_mutex //(ngx_event_accept.c)
															|-->if (ngx_shmtx_trylock(&ngx_accept_mutex)) //尝试获取accept锁,如果获取到进入该分支
																|-->if (ngx_accept_mutex_held && ngx_accept_events == 0)
																	|-->return OK

																|-->ngx_enable_accept_events //(ngx_event_accept.c)
																	|-->for (i = 0; i < cycle->listening.nelts; i++)
																		|-->c = ls[i].connection
																		|-->if (c == NULL || c->read->active)
																			continue
																			
																		|-->ngx_add_event(c->read, NGX_READ_EVENT, 0) //(ngx_event.h)
																			|-->ngx_event_actions.add //使用ngx_event_actions的add回调函数
																				|-->ngx_epoll_add_event //(ngx_epoll_module.c)
																					|-->epoll_ctl //添加事件
																
																|-->ngx_accept_events = 0
																|-->ngx_accept_mutex_held = 1
																|-->return NGX_OK

														|-->if (ngx_accept_mutex_held) //
															|-->ngx_disable_accept_events //(ngx_event_accept.c)
																|-->for (i = 0; i < cycle->listening.nelts; i++)
																	|-->ngx_del_event(c->read, NGX_READ_EVENT, NGX_DISABLE_EVENT) //

															|-->ngx_accept_mutex_held = 0;

														|-->flags |= NGX_POST_EVENTS //对falg进行与处理,后面的步骤需要
														
												|-->ngx_process_events //(ngx_event.h)
													|-->ngx_event_actions.process_events //使用回调函数
														|-->ngx_epoll_process_events //(ngx_epoll_module.c)
															|-->events = epoll_wait(ep, event_list, (int) nevents, timer) //等待数据的到来
															|-->for (i = 0; i < events; i++)
																|-->if ((revents & EPOLLIN) && rev->active)
																	|--> rev->ready = 1
																	|-->if (flags & NGX_POST_EVENTS)
																		|-->queue = rev->accept ? &ngx_posted_accept_events : &ngx_posted_events
																		|-->ngx_post_event(rev, queue)
																		
																	|-->else
																		|-->rev->handler //(ngx_epoll_module.c)
																			|-->ngx_event_accept //(ngx_event_accept.c)
																				|-->ls->handler //(ngx_event_accept.c)
																		
																|-->wev = c->write
																|-->if ((revents & EPOLLOUT) && wev->active)
																	|-->wev->ready = 1
																	|-->if (flags & NGX_POST_EVENTS)
																		|-->ngx_post_event(wev, &ngx_posted_events)
																		
																	|-->else
																		|-->wev->handler //()
												
												|-->ngx_event_process_posted(cycle, &ngx_posted_accept_events) //
												
												|--> if (ngx_accept_mutex_held)
													|-->ngx_shmtx_unlock(&ngx_accept_mutex)
													
												|-->ngx_event_process_posted(cycle, &ngx_posted_events)
																		
							|-->default: //父进程
								|-->break //不做任何动作，直接break
								
						|-->return pid
						
					|-->ngx_pass_open_channel //
		
			|-->ngx_start_cache_manager_processes(cycle, 0) //(ngx_process_cycle.c)
				|-->ngx_cache_manager_process_cycle //(ngx_process_cycle.c)
				
			|-->for ( ;; ) //父进程进入loop循环
				|-->
					
					
					
|-->ngx_epoll_add_event //(ngx_epoll_module.c)
	|-->epoll_ctl //
	
|-->ngx_epoll_eventfd_handler //(ngx_epoll_module.c)
	|-->epoll_ctl
	
|-->ngx_epoll_add_connection //(ngx_epoll_module.c)

|-->ngx_epoll_del_connection //

|-->ngx_epoll_del_event //
	

|-->ngx_event_core_init_conf //(ngx_event.c)

|-->ngx_event_process_init //(ngx_event.c)

|-->ngx_conf_parse //(ngx_conf_file.c)
	|-->ngx_conf_handler //(ngx_conf_file.c) 
		|-->cmd = cf->cycle->modules[i]->commands //
			|-->


|-->ngx_conf_parse //(ngx_conf_file.c)
	|-->ngx_conf_handler //(ngx_conf_file.c)
		|-->ngx_events_block //(ngx_event.c)
			|-->for (i = 0; cf->cycle->modules[i]; i++)
				|-->if (cf->cycle->modules[i]->type != NGX_EVENT_MODULE)
					|-->continue
		
				|-->m = cf->cycle->modules[i]->ctx
				|-->if (m->create_conf)
					|-->m->create_conf //()
		
			|-->ngx_conf_parse//
		
			|-->for (i = 0; cf->cycle->modules[i]; i++)
				|-->if (cf->cycle->modules[i]->type != NGX_EVENT_MODULE)
					|-->continue
		
				|-->m = cf->cycle->modules[i]->ctx
				|-->if (m->init_conf)
					|-->m->init_conf //(ngx_event.c)
		
		

|-->ngx_event_process_init //(ngx_event.c)
	|-->ngx_event_accept //(ngx_event_accept.c)
		|-->


|-->ngx_http_block //(ngx_http.c)
	|-->for (m = 0; cf->cycle->modules[m]; m++) //进行轮训
		|-->if (cf->cycle->modules[m]->type != NGX_HTTP_MODULE)
			|-->continue
			
		|-->module = cf->cycle->modules[m]->ctx
		|-->mi = cf->cycle->modules[m]->ctx_index
		
		|-->if (module->create_main_conf)
			|-->ctx->main_conf[mi] = module->create_main_conf //
			
		|-->if (module->create_srv_conf)
			|-->ctx->srv_conf[mi] = module->create_srv_conf //
			
		|-->if (module->create_loc_conf)
			|-->ctx->loc_conf[mi] = module->create_loc_conf //
			
	|-->for (m = 0; cf->cycle->modules[m]; m++) //进行轮训
		|-->if (cf->cycle->modules[m]->type != NGX_HTTP_MODULE)
			|-->continue
			
		|-->module = cf->cycle->modules[m]->ctx
		
		|-->if (module->preconfiguration)
			|-->module->preconfiguration //
			
	|-->ngx_conf_parse //
	
	|-->for (m = 0; cf->cycle->modules[m]; m++)
		|-->if (cf->cycle->modules[m]->type != NGX_HTTP_MODULE)
			|-->continue
			
		|-->module = cf->cycle->modules[m]->ctx
		
		|-->if (module->init_main_conf)
			|-->module->init_main_conf //
			
		|-->ngx_http_merge_servers //
		
	|-->for (s = 0; s < cmcf->servers.nelts; s++)
		|-->ngx_http_init_locations //()
		
		|-->ngx_http_init_static_location_trees //()
		
	|-->ngx_http_init_phases //
	
	|-->ngx_http_init_headers_in_hash //
	
	|-->for (m = 0; cf->cycle->modules[m]; m++)
		|-->if (cf->cycle->modules[m]->type != NGX_HTTP_MODULE)
			|-->continue
			
		|-->module = cf->cycle->modules[m]->ctx
		
		|-->if (module->postconfiguration)
			|-->module->postconfiguration //
			
	|-->ngx_http_variables_init_vars //()
	
	|-->ngx_http_init_phase_handlers //()
		
	|-->ngx_http_optimize_servers //(ngx_http.c)
		|-->ngx_http_init_listening //(ngx_http.c)
			|-->ngx_http_add_listening //(ngx_http.c)
				|-->ls->handler = ngx_http_init_connection //设置回调函数

				
|-->ngx_http_core_server //(ngx_http_core_module.c) NGX_HTTP_MODULE
	|-->for (i = 0; cf->cycle->modules[i]; i++)
		|-->if (cf->cycle->modules[i]->type != NGX_HTTP_MODULE)
			|-->continue

		|-->module = cf->cycle->modules[i]->ctx
		
		|-->if (module->create_srv_conf) 
			|-->mconf = module->create_srv_conf(cf) //回调函数
				|-->case ngx_http_core_module:
					|-->ngx_http_core_create_srv_conf //(ngx_http_core_module.c)
						|-->ngx_array_init //
						|-->

		|-->if (module->create_loc_conf)
			|-->mconf = module->create_loc_conf(cf) //回调函数
				|-->ngx_http_core_create_loc_conf //(ngx_http_core_module.c)
					|-->

		|-->rv = ngx_conf_parse(cf, NULL) //对数据进行解析
		
		|-->if (rv == NGX_CONF_OK && !cscf->listen)
			|-->ngx_sock_ntop //(ngx_inet.c)
			|-->ngx_http_add_listen //(ngx_http.c)
				|-->ngx_http_add_addresses //(ngx_http.c)
					|-->ngx_http_add_server //(ngx_http.c)
					|-->ngx_http_add_address //(ngx_http.c)
						|-->ngx_http_add_server //(ngx_http.c)

|-->ngx_http_upstream_server //() NGX_HTTP_MODULE

