|-----------------------重要数据结构-------------------------------------
|-->typedef struct ngx_module_s          ngx_module_t
|-->typedef struct ngx_conf_s            ngx_conf_t
|-->typedef struct ngx_cycle_s           ngx_cycle_t
|-->typedef struct ngx_pool_s            ngx_pool_t
|-->typedef struct ngx_chain_s           ngx_chain_t
|-->typedef struct ngx_log_s             ngx_log_t
|-->typedef struct ngx_open_file_s       ngx_open_file_t
|-->typedef struct ngx_command_s         ngx_command_t
|-->typedef struct ngx_file_s            ngx_file_t
|-->typedef struct ngx_event_s           ngx_event_t
|-->typedef struct ngx_event_aio_s       ngx_event_aio_t
|-->typedef struct ngx_connection_s      ngx_connection_t
|-->typedef struct ngx_thread_task_s     ngx_thread_task_t
|-->typedef struct ngx_ssl_s             ngx_ssl_t
|-->typedef struct ngx_ssl_connection_s  ngx_ssl_connection_t
|-->typedef struct ngx_udp_connection_s  ngx_udp_connection_t
|-->typedef u_char *(*ngx_log_handler_pt) (ngx_log_t *log, u_char *buf, size_t len)
|-->typedef void (*ngx_log_writer_pt) (ngx_log_t *log, ngx_uint_t level, u_char *buf, size_t len)
|-->#define NGX_ERROR_LOG_PATH  "logs/error.log"


|-->log文件操作数据结构体ngx_open_file_s //(ngx_conf_file.h)
	|-->struct ngx_open_file_s {
		ngx_fd_t              fd;
		ngx_str_t             name;

		void                (*flush)(ngx_open_file_t *file, ngx_log_t *log); //flush函数指针
		void                 *data;
	};


|-->log数据结构体ngx_log_s //(ngx_log.h)
	|-->struct ngx_log_s {
		ngx_uint_t           log_level;  
		ngx_open_file_t     *file;       

		ngx_atomic_uint_t    connection; 

		time_t               disk_full_time;

		ngx_log_handler_pt   handler; //函数指针 指针 
		void                *data;       

		ngx_log_writer_pt    writer;     
		void                *wdata;

		/*
		 * we declare "action" as "char *" because the actions are usually
		 * the static strings and in the "u_char *" case we have to override
		 * their types all the time
		 */ 

		char                *action;

		ngx_log_t           *next;
	};


|-->ngx_cycle数据结构体ngx_cycle_s //(ngx_cycle.h)
	|-->struct ngx_cycle_s {
		void                  ****conf_ctx;
		ngx_pool_t               *pool;

		ngx_log_t                *log;
		ngx_log_t                 new_log;

		ngx_uint_t                log_use_stderr;  /* unsigned  log_use_stderr:1; */

		ngx_connection_t        **files;
		ngx_connection_t         *free_connections;
		ngx_uint_t                free_connection_n;

		ngx_module_t            **modules;
		ngx_uint_t                modules_n;
		ngx_uint_t                modules_used;    /* unsigned  modules_used:1; */

		ngx_queue_t               reusable_connections_queue;
		ngx_uint_t                reusable_connections_n;

		ngx_array_t               listening;
		ngx_array_t               paths;

		ngx_array_t               config_dump;
		ngx_rbtree_t              config_dump_rbtree;
		ngx_rbtree_node_t         config_dump_sentinel;

		ngx_list_t                open_files;
		ngx_list_t                shared_memory;

		ngx_uint_t                connection_n;
		ngx_uint_t                files_n;
		ngx_connection_t         *connections;
		ngx_event_t              *read_events;
		ngx_event_t              *write_events;

		ngx_cycle_t              *old_cycle;

		ngx_str_t                 conf_file;
		ngx_str_t                 conf_param;
		ngx_str_t                 conf_prefix;
		ngx_str_t                 prefix;
		ngx_str_t                 lock_file;
		ngx_str_t                 hostname;
	};

|-->ngx_event_actions事件处理结构体(对应不同清空的执行动作) //(ngx_event.h)
	|-->typedef struct {
		ngx_int_t  (*add)(ngx_event_t *ev, ngx_int_t event, ngx_uint_t flags);
		ngx_int_t  (*del)(ngx_event_t *ev, ngx_int_t event, ngx_uint_t flags);

		ngx_int_t  (*enable)(ngx_event_t *ev, ngx_int_t event, ngx_uint_t flags);
		ngx_int_t  (*disable)(ngx_event_t *ev, ngx_int_t event, ngx_uint_t flags);

		ngx_int_t  (*add_conn)(ngx_connection_t *c);
		ngx_int_t  (*del_conn)(ngx_connection_t *c, ngx_uint_t flags);

		ngx_int_t  (*notify)(ngx_event_handler_pt handler);

		ngx_int_t  (*process_events)(ngx_cycle_t *cycle, ngx_msec_t timer,
									 ngx_uint_t flags);

		ngx_int_t  (*init)(ngx_cycle_t *cycle, ngx_msec_t timer);
		void       (*done)(ngx_cycle_t *cycle);
	} ngx_event_actions_t; 

|-->ngx_event_module事件结构体(包含配置创建和初始化) //(ngx_event.h)
	|-->typedef struct {
		ngx_str_t              *name;        
			
		void                 *(*create_conf)(ngx_cycle_t *cycle);
		char                 *(*init_conf)(ngx_cycle_t *cycle, void *conf);

		ngx_event_actions_t     actions;     
	} ngx_event_module_t;
	
|-->ngx_module module结构体 //(ngx_module.h)
	|-->struct ngx_module_s {
		ngx_uint_t            ctx_index;
		ngx_uint_t            index;

		char                 *name;

		ngx_uint_t            spare0;
		ngx_uint_t            spare1;

		ngx_uint_t            version;
		const char           *signature;

		void                 *ctx;
		ngx_command_t        *commands;
		ngx_uint_t            type;

		ngx_int_t           (*init_master)(ngx_log_t *log);

		ngx_int_t           (*init_module)(ngx_cycle_t *cycle);

		ngx_int_t           (*init_process)(ngx_cycle_t *cycle);
		ngx_int_t           (*init_thread)(ngx_cycle_t *cycle);
		void                (*exit_thread)(ngx_cycle_t *cycle);
		void                (*exit_process)(ngx_cycle_t *cycle);

		void                (*exit_master)(ngx_cycle_t *cycle);

		uintptr_t             spare_hook0;
		uintptr_t             spare_hook1;
		uintptr_t             spare_hook2;
		uintptr_t             spare_hook3;
		uintptr_t             spare_hook4;
		uintptr_t             spare_hook5;
		uintptr_t             spare_hook6;
		uintptr_t             spare_hook7;
	};
	
|-->static ngx_event_module_t  ngx_epoll_module_ctx = {
    &epoll_name,
    ngx_epoll_create_conf,               /* create configuration */
    ngx_epoll_init_conf,                 /* init configuration */

    {
        ngx_epoll_add_event,             /* add an event */
        ngx_epoll_del_event,             /* delete an event */
        ngx_epoll_add_event,             /* enable an event */
        ngx_epoll_del_event,             /* disable an event */
        ngx_epoll_add_connection,        /* add an connection */
        ngx_epoll_del_connection,        /* delete an connection */
#if (NGX_HAVE_EVENTFD)
        ngx_epoll_notify,                /* trigger a notify */
#else
        NULL,                            /* trigger a notify */
#endif
        ngx_epoll_process_events,        /* process the events */
        ngx_epoll_init,                  /* init the events */
        ngx_epoll_done,                  /* done the events */
    }
};

#define NGX_CORE_MODULE      0x45524F43
#define NGX_EVENT_MODULE     0x544E5645

ngx_module_t  ngx_epoll_module = {
    NGX_MODULE_V1,
    &ngx_epoll_module_ctx,               /* module context */
    ngx_epoll_commands,                  /* module directives */
    NGX_EVENT_MODULE,                    /* module type */
    NULL,                                /* init master */
    NULL,                                /* init module */
    NULL,                                /* init process */
    NULL,                                /* init thread */
    NULL,                                /* exit thread */
    NULL,                                /* exit process */
    NULL,                                /* exit master */
    NGX_MODULE_V1_PADDING
};

ngx_module_t  ngx_event_core_module = {
    NGX_MODULE_V1,
    &ngx_event_core_module_ctx,            /* module context */
    ngx_event_core_commands,               /* module directives */
    NGX_EVENT_MODULE,                      /* module type */
    NULL,                                  /* init master */
    ngx_event_module_init,                 /* init module */
    ngx_event_process_init,                /* init process */
    NULL,                                  /* init thread */
    NULL,                                  /* exit thread */
    NULL,                                  /* exit process */
    NULL,                                  /* exit master */
    NGX_MODULE_V1_PADDING
}; //(ngx_event.c) evnet事件的核心定义，其包含epoll结构体的关联

static ngx_event_module_t  ngx_event_core_module_ctx = {
    &event_core_name,
    ngx_event_core_create_conf,            /* create configuration */
    ngx_event_core_init_conf,              /* init configuration */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL }
};//(ngx_event.c)

static ngx_command_t  ngx_http_commands[] = {
    { ngx_string("http"),
      NGX_MAIN_CONF|NGX_CONF_BLOCK|NGX_CONF_NOARGS,
      ngx_http_block,
      0,
      0,
      NULL },

      ngx_null_command
}; //http模块解析指令

static ngx_core_module_t  ngx_http_module_ctx = {
    ngx_string("http"),
    NULL,
    NULL
};

ngx_module_t  ngx_http_module = {
    NGX_MODULE_V1,
    &ngx_http_module_ctx,                  /* module context */
    ngx_http_commands,                     /* module directives */
    NGX_CORE_MODULE,                       /* module type */
    NULL,                                  /* init master */
    NULL,                                  /* init module */
    NULL,                                  /* init process */
    NULL,                                  /* init thread */
    NULL,                                  /* exit thread */
    NULL,                                  /* exit process */
    NULL,                                  /* exit master */
    NGX_MODULE_V1_PADDING
};

ngx_module_t  ngx_stream_module = {
    NGX_MODULE_V1,
    &ngx_stream_module_ctx,                /* module context */
    ngx_stream_commands,                   /* module directives */
    NGX_CORE_MODULE,                       /* module type */
    NULL,                                  /* init master */
    NULL,                                  /* init module */
    NULL,                                  /* init process */
    NULL,                                  /* init thread */
    NULL,                                  /* exit thread */
    NULL,                                  /* exit process */
    NULL,                                  /* exit master */
    NGX_MODULE_V1_PADDING
};//(ngx_stream.c) tcp/udp 负载均衡模块


|-->command指令集 //(ngx_conf_file.h)
	|-->struct ngx_command_s {
	    ngx_str_t             name;
	    ngx_uint_t            type;
	    char               *(*set)(ngx_conf_t *cf, ngx_command_t *cmd, void *conf);
	    ngx_uint_t            conf;
	    ngx_uint_t            offset;
	    void                 *post;
	};

ngx_module_t *ngx_modules[] = {
    &ngx_core_module,
    &ngx_errlog_module,
    &ngx_conf_module,
    &ngx_regex_module,
    &ngx_events_module,
    &ngx_event_core_module,
    &ngx_epoll_module,
    &ngx_http_module,
    &ngx_http_core_module,
    &ngx_http_log_module,
    &ngx_http_upstream_module,
    &ngx_http_static_module,
    &ngx_http_autoindex_module,
    &ngx_http_index_module,
    &ngx_http_mirror_module,
    &ngx_http_try_files_module,
    &ngx_http_auth_basic_module,
    &ngx_http_access_module,
    &ngx_http_limit_conn_module,
    &ngx_http_limit_req_module,
    &ngx_http_geo_module,
    &ngx_http_map_module,
    &ngx_http_split_clients_module,
    &ngx_http_referer_module,
    &ngx_http_rewrite_module,
    &ngx_http_proxy_module,
    &ngx_http_fastcgi_module,
    &ngx_http_uwsgi_module,
    &ngx_http_scgi_module,
    &ngx_http_memcached_module,
    &ngx_http_empty_gif_module,
    &ngx_http_browser_module,
    &ngx_http_upstream_hash_module,
	&ngx_http_upstream_ip_hash_module,
    &ngx_http_upstream_least_conn_module,
    &ngx_http_upstream_random_module,
    &ngx_http_upstream_keepalive_module,
    &ngx_http_upstream_zone_module,
    &ngx_http_write_filter_module,
    &ngx_http_header_filter_module,
    &ngx_http_chunked_filter_module,
    &ngx_http_range_header_filter_module,
    &ngx_http_gzip_filter_module,
    &ngx_http_postpone_filter_module,
    &ngx_http_ssi_filter_module,
    &ngx_http_charset_filter_module,
    &ngx_http_userid_filter_module,
    &ngx_http_headers_filter_module,
    &ngx_http_copy_filter_module,
    &ngx_http_range_body_filter_module,
    &ngx_http_not_modified_filter_module,
    NULL
}; //(objs/ngx_modules.c) 所有module的集合

ngx_os_io_t ngx_os_io = {
    ngx_unix_recv,
    ngx_readv_chain,
    ngx_udp_unix_recv,
    ngx_unix_send,
    ngx_udp_unix_send,
    ngx_udp_unix_sendmsg_chain,
    ngx_writev_chain,
    0
};//(ngx_posix_init.c) linux系统下的默认socket操作函数组

static ngx_http_module_t  ngx_http_core_module_ctx = {
    ngx_http_core_preconfiguration,        /* preconfiguration */
    ngx_http_core_postconfiguration,       /* postconfiguration */

    ngx_http_core_create_main_conf,        /* create main configuration */
    ngx_http_core_init_main_conf,          /* init main configuration */

    ngx_http_core_create_srv_conf,         /* create server configuration */
    ngx_http_core_merge_srv_conf,          /* merge server configuration */

    ngx_http_core_create_loc_conf,         /* create location configuration */
    ngx_http_core_merge_loc_conf           /* merge location configuration */
};//(ngx_http_core_module.c) http模块的配置处理函数

ngx_module_t  ngx_http_core_module = {
    NGX_MODULE_V1,
    &ngx_http_core_module_ctx,             /* module context */
    ngx_http_core_commands,                /* module directives */
    NGX_HTTP_MODULE,                       /* module type */
    NULL,                                  /* init master */
    NULL,                                  /* init module */
    NULL,                                  /* init process */
    NULL,                                  /* init thread */
    NULL,                                  /* exit thread */
    NULL,                                  /* exit process */
    NULL,                                  /* exit master */
    NGX_MODULE_V1_PADDING
};//(ngx_http_core_module.c) http的核心处理模块

//ngx_thread_pool_module 线程池模块 //(ngx_thread_pool.c) 默认是不启用的，需要在configure时进行配置--with-threads进行开启
ngx_module_t  ngx_thread_pool_module = {
    NGX_MODULE_V1,
    &ngx_thread_pool_module_ctx,           /* module context */
    ngx_thread_pool_commands,              /* module directives */
    NGX_CORE_MODULE,                       /* module type */
    NULL,                                  /* init master */
    NULL,                                  /* init module */
    ngx_thread_pool_init_worker,           /* init process */
    NULL,                                  /* init thread */
    NULL,                                  /* exit thread */
    ngx_thread_pool_exit_worker,           /* exit process */
    NULL,                                  /* exit master */
    NGX_MODULE_V1_PADDING
}; 

ngx_module_t  ngx_http_upstream_module = {
    NGX_MODULE_V1,
    &ngx_http_upstream_module_ctx,         /* module context */
    ngx_http_upstream_commands,            /* module directives */
    NGX_HTTP_MODULE,                       /* module type */
    NULL,                                  /* init master */
    NULL,                                  /* init module */
    NULL,                                  /* init process */
    NULL,                                  /* init thread */
    NULL,                                  /* exit thread */
    NULL,                                  /* exit process */
    NULL,                                  /* exit master */
    NGX_MODULE_V1_PADDING
};//(ngx_http_upstream.c)负载均衡模块


|-->main //(nginx.c) nginx函数入口
	|-->ngx_max_sockets = -1 
	|-->ngx_time_init //初始化时间设置
	|-->ngx_regex_init //默认NGX_PCRE为true
	|-->ngx_log_init //log日志初始化	
	|-->ngx_memzero(&init_cycle, sizeof(ngx_cycle_t)) //清空init_cycle
	|-->init_cycle.log = log //将ngx_log的地址赋值给init_cycle.log
	|-->ngx_cycle = &init_cycle //
	|-->init_cycle.pool = ngx_create_pool //
	|-->ngx_process_options //处理配置选项(工作时添加的配置选项)
	|-->ngx_os_init //(ngx_posix_init.c)
	|-->ngx_crc32_table_init //(ngx_crc32.c)
	|-->ngx_slab_sizes_init //初始化slab
	|-->ngx_add_inherited_sockets //初始化socket继承设置
	|-->ngx_preinit_modules //预先初始化nginx模块
	|-->ngx_init_cycle //初始化nginx，包含module模块的初始化和配置文件的解析等
	|-->ngx_os_status //(ngx_posix_init.c) //打印一些os的状态值
	|-->ngx_init_signals //初始化信号及其对应的处理函数
	|-->ngx_create_pidfile //()
	|-->ngx_log_redirect_stderr //重定向标准错误日志
	|-->if (ngx_process == NGX_PROCESS_SINGLE) //默认不进入该状态
		|-->ngx_single_process_cycle //但工作状态模式
	
	|-->else //当ngx_process不等于NGX_PROCESS_SINGLE时进入该分支。默认进入该分支
		|-->ngx_master_process_cycle //master工作进程(会创建子进程，父进程进入loop循环)
				
				
|-----------------------tcp/udp负载均衡流程---------------------------|
|-->ngx_event_accept(server端accept数据) socket accept后的数据流向
	|-->ngx_stream_init_connection(tcp/udp负载均衡) 
		|--> ngx_stream_session_handler(session处理函数)  
			|-->ngx_stream_core_run_phases (数据解析，选择合适的解析执行函数)
				|-->ngx_stream_core_content_phase (数据内容解析)
					|-->ngx_stream_proxy_handler (负载均衡执行函数)
						|-->ngx_stream_proxy_connect (后端connect)
							|-->ngx_stream_proxy_connect_handler (最终连接proxy函数)
								|-->ngx_stream_proxy_init_upstream (初始化连接)
									|-->ngx_stream_proxy_process (负载均衡处理函数)
						
						
负载均衡数据中转流程(接收client并将其抓发到对端):
|-->ngx_stream_proxy_downstream_handler (处理clietn发送的数据并将其转发到对端)
	|-->ngx_stream_proxy_process_connection (处理连接)
		|-->ngx_stream_proxy_process (负载均衡处理函数,接收数据并将其转发到对端)
			|-->src->recv(接收client的数据)
			|-->ngx_stream_top_filter (将数据发送到对端)
			
负载均衡数据中转流程(接收对端数据最终发回client):
|-->ngx_stream_proxy_downstream_handler (处理对端发送的数据并将其转发到client)
	|-->ngx_stream_proxy_process_connection (处理连接)
		|-->ngx_stream_proxy_process (负载均衡处理函数)
			|-->src->recv(接收对端的数据)
			|-->ngx_stream_top_filter (将数据发送到client)	

|-------------------------http 数据流程流程 --------------------------|
accept状态:
|-->ngx_event_accept(server端accept数据) socket accept后的数据流向
	|-->ngx_http_init_connection (http connect初始化函数)
		|-->ngx_handle_read_event (将该连接添加到epoll监听队列中，开始进入下一个状态)
		
数据处理状态:
|-->ngx_http_wait_request_handler (等待数据接收)
	|-->ngx_http_process_request_line (处理接收到的数据)


|-------------------nginx重要的函数实现解析---------------------------|	
|-->ngx_log_init //(ngx_log.c)
	|-->ngx_log.file = &ngx_log_file 
	|-->ngx_log.log_level = NGX_LOG_NOTICE //设置打印等级
	|-->name = (u_char *) NGX_ERROR_LOG_PATH //获取文件名称
	|-->ngx_log_file.fd = ngx_open_file(name, NGX_FILE_APPEND,
								NGX_FILE_CREATE_OR_OPEN,
								NGX_FILE_DEFAULT_ACCESS) //打开文件, 当文件不存在时创建文件
								
	|-->return &ngx_log //返回ngx_log的地址
	
|-->ngx_slab_sizes_init //(ngx_slab.c)
	|-->ngx_slab_max_size = ngx_pagesize / 2
	|-->ngx_slab_exact_size = ngx_pagesize / (8 * sizeof(uintptr_t))
	
|-->ngx_add_inherited_sockets //(nginx.c)
	|-->ngx_array_init(&cycle->listening, cycle->pool, 10, sizeof(ngx_listening_t) //(ngx_array.h)
		|-->array->nelts = 0 
		|-->array->pool = pool
		|-->array->elts = ngx_palloc(pool, n * size) //对cycle->listening.elts进行分配，10个地址大小
	
	|-->ngx_inherited = 1 //赋值，后面的流程需要用到
	
	|-->ngx_set_inherited_sockets //(ngx_connection.c)
		|-->ls = cycle->listening.elts
		|-->for (i = 0; i < cycle->listening.nelts; i++) //进不去，nelts的值为0
		
|-->ngx_preinit_modules //(ngx_module.c)
	|-->for (i = 0; ngx_modules[i]; i++) //获取
		|-->ngx_modules[i]->index = i;
		|-->ngx_modules[i]->name = ngx_module_names[i];

	|-->ngx_modules_n = i //统计当前的module数量，用于后面的拷贝复制
	|-->ngx_max_module = ngx_modules_n + NGX_MAX_DYNAMIC_MODULES
		
|-->ngx_init_cycle //(ngx_cycle.c)
	|-->ngx_array_init(&cycle->listening, pool, n, sizeof(ngx_listening_t) //初始化listening
	|-->ngx_memzero(cycle->listening.elts, n * sizeof(ngx_listening_t))
	|-->ngx_queue_init(&cycle->reusable_connections_queue) //对队列进行初始化
	|-->cycle->conf_ctx = ngx_pcalloc(pool, ngx_max_module * sizeof(void *)) //分配空间
	
	|-->ngx_cycle_modules //(ngx_module.c)
		|-->cycle->modules = ngx_pcalloc(cycle->pool, (ngx_max_module + 1) * sizeof(ngx_module_t *)) //分配空间
		|-->ngx_memcpy(cycle->modules, ngx_modules, ngx_modules_n * sizeof(ngx_module_t *)) //将全局module拷贝到cycle->modules
		|-->cycle->modules_n = ngx_modules_n //当前module的数量
	
	|-->for (i = 0; cycle->modules[i]; i++) //对modules进行轮训判断其type值
		|-->if (cycle->modules[i]->type != NGX_CORE_MODULE) //对modules进行轮训判断其type值
			|-->continue //只要type=NGX_CORE_MODULE的module
		
		|-->module = cycle->modules[i]->ctx //获取结构体中ngx_event_module_t成员, 本次分析以ngx_event_core_module_ctx为例子
		|-->if (module->create_conf) //如果create_conf回调函数存在则调用回调
			module->create_conf //调用关联模块的回调函数
				|-->case ngx_core_module: //核心模块
					|-->ngx_core_module_create_conf //(nginx.c)
						|-->ccf->daemon = NGX_CONF_UNSET //初始化
						|-->ccf->master = NGX_CONF_UNSET //初始化
						|-->ccf->worker_processes = NGX_CONF_UNSET 
						
				|-->case ngx_regex_module: //反向连接模块
					|-->ngx_regex_create_conf //(ngx_regex.c)
					
				|-->case ngx_thread_pool_module: //线程池模块
					|-->ngx_thread_pool_create_conf //(ngx_thread_pool.c)
	
	|-->conf.args = ngx_array_create(pool, 10, sizeof(ngx_str_t)) 
	|-->conf.temp_pool = ngx_create_pool(NGX_CYCLE_POOL_SIZE, log)
	
	|-->conf.module_type = NGX_CORE_MODULE
	|-->conf.cmd_type = NGX_MAIN_CONF

	|-->ngx_conf_param //(ngx_conf_file.c)
		|-->param = &cf->cycle->conf_param
		|-->ngx_memzero(&b, sizeof(ngx_buf_t))//清空结构体b
		|-->ngx_memzero(&conf_file, sizeof(ngx_conf_file_t))
		|-->b.start = param->data
		|-->b.pos = param->data
		|-->b.last = param->data + param->len
		|-->b.end = b.last
		|-->b.temporary = 1
		|-->conf_file.file.fd = NGX_INVALID_FILE
		|-->conf_file.file.name.data = NULL
		|-->conf_file.line = 0
		|-->cf->conf_file = &conf_file
		|-->cf->conf_file->buffer = &b 
		|-->ngx_conf_parse(cf, NULL) //(ngx_conf_file.c) 对cf进行解析
		|-->cf->conf_file = NULL //
		
	|-->ngx_conf_parse //(ngx_conf_file.c)
		|-->if (filename) //filename是传入的第二个参数
			|-->fd = ngx_open_file(filename->data, NGX_FILE_RDONLY, NGX_FILE_OPEN, 0) //打开文件，实际调用的就是open函数, 返回fd
			|-->if(fd == NGX_INVALID_FILE)
				|-->return NGX_CONF_ERROR;
				
			|-->prev = cf->conf_file //使用prev将cf中的原始文件信息保存起来
			|-->cf->conf_file = &conf_file //使用一个新的变量
			
			|-->ngx_fd_info(fd, &cf->conf_file->file.info) //读取文件属性(实际调用的是fstat，读取文件的属性)
			|-->cf->conf_file->buffer = &buf //使用buf进行存储
			|-->buf.start = ngx_alloc(NGX_CONF_BUFFER, cf->log) //进行空间分配
			|-->buf.pos = buf.start
			|-->buf.last = buf.start
			|-->buf.end = buf.last + NGX_CONF_BUFFER //NGX_CONF_BUFFER = 4096, 指定偏移量
			|-->buf.temporary = 1
			|-->cf->conf_file->file.fd = fd //将fd进行赋值
			|-->cf->conf_file->file.name.len = filename->len
			|-->cf->conf_file->file.name.data = filename->data
			|-->cf->conf_file->file.offset = 0
			|-->cf->conf_file->file.log = cf->log
			|-->cf->conf_file->line = 1
			|-->type = parse_file //设置类型为文件解析
			
		|-->else if (cf->conf_file->file.fd != NGX_INVALID_FILE) //如果filename为空，但fd不为初始值
			|-->type = parse_block //设置为解析block
			
		|-->else //如果filename为空，且cf->conf_file->file.fd为NGX_INVALID_FILE
			|-->type = parse_param //设置为解析参数
			
		|-->for ( ;; )
			|-->rc = ngx_conf_read_token(cf) //(ngx_conf_file.c)
				|-->cf->args->nelts = 0
				|-->start = b->pos
				|-->start_line = cf->conf_file->line
				|-->file_size = ngx_file_size(&cf->conf_file->file.info) //获取文件大小
					
			|-->ngx_conf_handler //(ngx_conf_file.c)
				|-->name = cf->args->elts
				
				|-->for (i = 0; cf->cycle->modules[i]; i++)
					|-->cmd = cf->cycle->modules[i]->commands //获取所有modules模块的cmd命令
					|-->if (cmd == NULL)
						|-->continue
						
					|-->for ( /* void */ ; cmd->name.len; cmd++)
						|-->if (name->len != cmd->name.len)
							|-->continue
							
						|-->if (ngx_strcmp(name->data, cmd->name.data) != 0)
							|-->continue
							
						|-->found = 1
						
						|-->if (cf->cycle->modules[i]->type != NGX_CONF_MODULE && cf->cycle->modules[i]->type != cf->module_type)
							|-->continue
				
						|-->if (!(cmd->type & cf->cmd_type))
							|-->continue
							
						|-->if ((cmd->type & NGX_CONF_BLOCK) && last != NGX_CONF_BLOCK_START)
							|-->return NGX_ERROR
							
						|-->cmd->set(cf, cmd, conf) //调用cmd中的set回调函数
							|-->case ngx_http_commands: //http的cmd
								|-->ngx_http_block // 主要是解析http相关的配置文件和设置accpet的回调函数

							|-->case ngx_http_core_commands: 
								|-->case "server":
									|-->ngx_http_core_server //配置文件中server字段的处理函数

								|-->case "listen":
									|-->ngx_http_core_listen //(ngx_http_core_module.c)

	|-->for (i = 0; cycle->modules[i]; i++) //对全局modules指针数组进行轮巡
		|-->if (cycle->modules[i]->type != NGX_CORE_MODULE)
			|-->continue //只要type=NGX_CORE_MODULE的module
			
		|-->module = cycle->modules[i]->ctx 
		|-->if (module->init_conf) //如果create_conf回调函数存在则调用回调
			|-->module->init_conf //调用各个关联模块的回调函数
				|-->case ngx_core_module:
					|-->ngx_core_module_init_conf //(ngx_event.c)
						|-->ngx_conf_init_value(ccf->daemon, 1)
						|-->ngx_conf_init_value(ccf->master, 1) //(ngx_conf_file.h)
							|-->if (conf == NGX_CONF_UNSET)
								|-->ccf->master = 1 //设置master的值为1，该值在后面用来判断ngx_process工作类型
								
						|-->ngx_conf_init_value(ccf->worker_processes, 1) //将worker_processes的值设置为1
						
				|-->case ngx_regex_module:
					|-->ngx_regex_init_conf //()
				
				|-->ngx_events_module:
					|-->ngx_event_init_conf //(ngx_event.c)
						|-->ngx_get_conf(cycle->conf_ctx, ngx_events_module) //(ngx_event.c)
							|-->return conf_ctx[module.index] //(ngx_conf_file.h)
		
				|-->ngx_thread_pool_module //线程池模块
					|-->ngx_thread_pool_init_conf //(ngx_thread_pool.c)

|-->ngx_init_signals //(ngx_process.c) 
	|-->for (sig = signals; sig->signo != 0; sig++) //对signals数组进行遍历，并设置其signal信号执行函数
		|-->if (sig->handler) //如果设置了回调函数，则将其添加到回调函数中
			|-->sa.sa_sigaction = sig->handler
			|-->sa.sa_flags = SA_SIGINFO
		|-->else
			|-->sa.sa_handler = SIG_IGN
			
		|-->sigemptyset(&sa.sa_mask)
		|-->sigaction //设置信号执行函数
		
|-->ngx_master_process_cycle //(ngx_process_cycle.c)
	|-->ccf = (ngx_core_conf_t *) ngx_get_conf(cycle->conf_ctx, ngx_core_module) //获取conf_ctx[0]
	|-->ngx_start_worker_processes //启动工作进程, 进程数量来自配置文件
	|-->ngx_start_cache_manager_processes(cycle, 0) //(ngx_process_cycle.c)
	|-->for ( ;; ) //父进程进入loop循环	
	
|-->ngx_start_worker_processes //(ngx_process_cycle.c)
	|-->for (i = 0; i < n; i++) //worker_processes的数值来自nginx.conf文件的配置,默认为1
		|-->ngx_spawn_process //创建进程,并使用传入的函数作为进程执行函数
			|-->ngx_process_slot = s
			|-->pid = fork()
			|-->switch (pid)
				|-->case -1://创建失败
					|-->NGX_INVALID_PID
					
				|-->case 0://子进程
					|-->ngx_parent = ngx_pid
					|-->ngx_pid = ngx_getpid()
					|-->proc(cycle, data) //执行传入的函数指针
						|-->ngx_worker_process_cycle //实际执行的函数为这个
															
				|-->default: //父进程
					|-->break //不做任何动作，直接break
					
			|-->return pid
			
		|-->ngx_pass_open_channel //

|-->ngx_worker_process_cycle //(ngx_process_cycle.c) 工作进程的主函数
	|-->ngx_process = NGX_PROCESS_WORKER //将其设置为NGX_PROCESS_WORKER
	|-->ngx_worker = worker
	|-->ngx_worker_process_init //(ngx_process_cycle.c) worker初始化操作

	|-->for ( ;; ) //进入loop
		|-->ngx_process_events_and_timers //(ngx_event.c) //nginx的数据处理，其函数见下面的函数说明


|-->ngx_conf_handler //(ngx_conf_file.c) 配置文件的处理函数,根据配置文件中不同字段调用不同的处理函数
	|-->name = cf->args->elts
	|-->for (i = 0; cf->cycle->modules[i]; i++)
		|-->cmd = cf->cycle->modules[i]->commands //获取所有modules模块的cmd命令
		|-->if (cmd == NULL)
			|-->continue
			
		|-->for ( /* void */ ; cmd->name.len; cmd++)
			|-->if (name->len != cmd->name.len)
				|-->continue
				
			|-->if (ngx_strcmp(name->data, cmd->name.data) != 0)
				|-->continue
				
			|-->found = 1
			
			|-->if (cf->cycle->modules[i]->type != NGX_CONF_MODULE && cf->cycle->modules[i]->type != cf->module_type)
				|-->continue
	
			|-->if (!(cmd->type & cf->cmd_type))
				|-->continue
				
			|-->if ((cmd->type & NGX_CONF_BLOCK) && last != NGX_CONF_BLOCK_START)
				|-->return NGX_ERROR
				
			|-->cmd->set(cf, cmd, conf) //调用cmd中的set回调函数
				|-->case ngx_http_commands: //http的cmd
					|-->ngx_http_block // 主要是解析http相关的配置文件和设置accpet的回调函数

				|-->case ngx_http_core_commands: 
					|-->case "server":
						|-->ngx_http_core_server //配置文件中server字段的处理函数

					|-->case "listen":
						|-->ngx_http_core_listen //(ngx_http_core_module.c)

|-->ngx_http_block //(ngx_http.c)
	|-->ngx_http_max_module = ngx_count_modules //获取模块中type为NGX_HTTP_MODULE的个数
	|-->ctx->main_conf = ngx_pcalloc //预分配ngx_http_max_module个void型的指针数据
	|-->ctx->srv_conf = ngx_pcalloc //预分配ngx_http_max_module个void型的指针数据
	|-->ctx->loc_conf = ngx_pcalloc 
	
	|-->for (m = 0; cf->cycle->modules[m]; m++) //进行轮训
		|-->if (cf->cycle->modules[m]->type != NGX_HTTP_MODULE)
			|-->continue
			
		|-->module = cf->cycle->modules[m]->ctx
		|-->mi = cf->cycle->modules[m]->ctx_index
		
		|-->if (module->create_main_conf)
			|-->ctx->main_conf[mi] = module->create_main_conf() //调用回调函数
				|-->case ngx_http_core_module:
					|-->ngx_http_core_create_main_conf //(ngx_http_core_module.c)
					
				|-->case ngx_http_upstream_module:
					|-->ngx_http_upstream_create_main_conf //(ngx_http_upstream.c)
					
			
		|-->if (module->create_srv_conf)
			|-->ctx->srv_conf[mi] = module->create_srv_conf //调用回调函数
				|-->case ngx_http_core_module:
					|-->ngx_http_core_create_srv_conf //(ngx_http_core_module.c)
						|-->
			
		|-->if (module->create_loc_conf)
			|-->ctx->loc_conf[mi] = module->create_loc_conf //调用回调函数
			
	|-->for (m = 0; cf->cycle->modules[m]; m++) //进行轮训
		|-->if (cf->cycle->modules[m]->type != NGX_HTTP_MODULE)
			|-->continue
			
		|-->module = cf->cycle->modules[m]->ctx
		
		|-->if (module->preconfiguration)
			|-->module->preconfiguration //调用回调函数
			
	|-->ngx_conf_parse //解析文件内容
	
	|-->for (m = 0; cf->cycle->modules[m]; m++)
		|-->if (cf->cycle->modules[m]->type != NGX_HTTP_MODULE)
			|-->continue
			
		|-->module = cf->cycle->modules[m]->ctx
		
		|-->if (module->init_main_conf)
			|-->module->init_main_conf //调用回调函数
				|-->case ngx_http_upstream_module:
					|-->ngx_http_upstream_init_main_conf //(ngx_http_upstream.c)
						|-->for (i = 0; i < umcf->upstreams.nelts; i++)
							|-->init() //调用init初始化函数，默认情况下为 ngx_http_upstream_init_round_robin
	
		|-->ngx_http_merge_servers //
		
	|-->for (s = 0; s < cmcf->servers.nelts; s++)
		|-->ngx_http_init_locations //()
		
		|-->ngx_http_init_static_location_trees //()
		
	|-->ngx_http_init_phases //
	
	|-->ngx_http_init_headers_in_hash //
	
	|-->for (m = 0; cf->cycle->modules[m]; m++)
		|-->if (cf->cycle->modules[m]->type != NGX_HTTP_MODULE)
			|-->continue
			
		|-->module = cf->cycle->modules[m]->ctx
		
		|-->if (module->postconfiguration)
			|-->module->postconfiguration //
			
	|-->ngx_http_variables_init_vars //()
	
	|-->ngx_http_init_phase_handlers //(ngx_http.c) 初始化checker,用于重定向使用
		|-->
		
	|-->ngx_http_optimize_servers //(ngx_http.c)
		|-->ngx_http_init_listening //(ngx_http.c)
			|-->ngx_http_add_listening //(ngx_http.c)
				|-->ls->handler = ngx_http_init_connection //设置回调函数, 用于accept处理

|-->ngx_http_upstream_init_round_robin //(ngx_http_upstream_round_robin.c) 负载均衡默认处理方法
	|-->us->peer.init = ngx_http_upstream_init_round_robin_peer
	|-->

				
|-->ngx_http_core_server //(ngx_http_core_module.c) 配置文件中server字段的解析
	|-->for (i = 0; cf->cycle->modules[i]; i++)
		|-->if (cf->cycle->modules[i]->type != NGX_HTTP_MODULE)
			|-->continue

		|-->module = cf->cycle->modules[i]->ctx
		
		|-->if (module->create_srv_conf) 
			|-->mconf = module->create_srv_conf(cf) //回调函数
				|-->case ngx_http_core_module:
					|-->ngx_http_core_create_srv_conf //(ngx_http_core_module.c)
						|-->ngx_array_init //

		|-->if (module->create_loc_conf)
			|-->mconf = module->create_loc_conf(cf) //回调函数
				|-->ngx_http_core_create_loc_conf //(ngx_http_core_module.c)

		|-->rv = ngx_conf_parse(cf, NULL) //对数据进行解析
		
		|-->if (rv == NGX_CONF_OK && !cscf->listen)
			|-->ngx_sock_ntop //(ngx_inet.c)
			|-->ngx_http_add_listen //(ngx_http.c)
				|-->ngx_http_add_addresses //(ngx_http.c)
					|-->ngx_http_add_server //(ngx_http.c)
					|-->ngx_http_add_address //(ngx_http.c)
						|-->ngx_http_add_server //(ngx_http.c)

	|-->for (i = 0; cf->cycle->modules[i]; i++)
		|-->if (cf->cycle->modules[i]->type != NGX_HTTP_MODULE)
			|-->continue;

		|-->module = cf->cycle->modules[i]->ctx //
					
|-->ngx_worker_process_init //(ngx_process_cycle.c) worker的初始化函数，用于初始化绑定系统调用关系(epoll)
	|-->ccf = (ngx_core_conf_t *) ngx_get_conf(cycle->conf_ctx, ngx_core_module)
	|-->for (i = 0; cycle->modules[i]; i++) 
		|-->if (cycle->modules[i]->init_process)
			|-->cycle->modules[i]->init_process(cycle) //回调函数
				|-->case ngx_thread_pool_module: //线程池模块
					|-->ngx_thread_pool_init_worker //(ngx_thread_pool.c)
				
				|-->case ngx_event_core_module: //event模块
					|-->ngx_event_process_init //(ngx_event.c) event初始化函数,具体的实现见下面的函数分析

	|-->ngx_add_channel_event(cycle, ngx_channel, NGX_READ_EVENT, ngx_channel_handler)
	

|-->ngx_process_events_and_timers //(ngx_event.c) //nginx的真正执行所在，等待数据的到来并进行相应的处理
	|-->if (ngx_use_accept_mutex) //是否使用accept锁, 默认情况下是不会使用锁的
		|-->if (ngx_accept_disabled > 0)
			|-->ngx_accept_disabled--
		
		|-->else //ngx_accept_disabled <= 0的情况
			|-->if(ngx_trylock_accept_mutex == NGX_ERROR ) //获取accept_mutex锁
				|-->return;

			|-->if (ngx_accept_mutex_held) //
				|-->ngx_disable_accept_events //(ngx_event_accept.c)
					|-->for (i = 0; i < cycle->listening.nelts; i++)
						|-->ngx_del_event(c->read, NGX_READ_EVENT, NGX_DISABLE_EVENT) //

				|-->ngx_accept_mutex_held = 0;

			|-->flags |= NGX_POST_EVENTS //对falg进行与处理,后面的步骤需要

	|-->delta = ngx_current_msec
			
	|-->ngx_process_events //(ngx_event.h)
		|-->ngx_event_actions.process_events //使用回调函数
			|-->ngx_epoll_process_events //(ngx_epoll_module.c) 具体的事件处理, 其内部处理流程常见下面的函数梳理

	|-->delta = ngx_current_msec - delta
			
	|-->ngx_event_process_posted(cycle, &ngx_posted_accept_events)//其处理流程见下面的分析
	
	|-->if (ngx_accept_mutex_held)
		|-->ngx_shmtx_unlock(&ngx_accept_mutex)

	|-->if (delta)
		|-->ngx_event_expire_timers //(ngx_event_timer.c)
		
	|-->ngx_event_process_posted(cycle, &ngx_posted_events) //处理插入链表中的数据	

|-->ngx_trylock_accept_mutex //(ngx_event_accept.c) 获取accept_mutex锁
	|-->if (ngx_shmtx_trylock(&ngx_accept_mutex)) //尝试获取accept锁,如果获取到进入该分支
		|-->if (ngx_accept_mutex_held && ngx_accept_events == 0)
			|-->return OK

		|-->ngx_enable_accept_events //(ngx_event_accept.c)
			|-->for (i = 0; i < cycle->listening.nelts; i++)
				|-->c = ls[i].connection
				|-->if (c == NULL || c->read->active)
					continue
					
				|-->ngx_add_event(c->read, NGX_READ_EVENT, 0) //函数的实现参见函数分析说明
		
		|-->ngx_accept_events = 0
		|-->ngx_accept_mutex_held = 1
		|-->return NGX_OK

	|-->if (ngx_accept_mutex_held)
		|-->ngx_disable_accept_events
		|-->ngx_accept_mutex_held = 0

	|-->return NGX_OK

|-->ngx_epoll_process_events //(ngx_epoll_module.c) 具体的事件处理, 其内部处理流程常见下面的函数梳理
	|-->events = epoll_wait(ep, event_list, (int) nevents, timer) //等待数据的到来
	|-->for (i = 0; i < events; i++)
		|-->if ((revents & EPOLLIN) && rev->active)
			|-->rev->available = 1 //在后面的rcv->handler函数中需要检查该变量
			|--> rev->ready = 1
			|-->if (flags & NGX_POST_EVENTS)
				|-->queue = rev->accept ? &ngx_posted_accept_events : &ngx_posted_events
				|-->ngx_post_event(rev, queue) //见数据插入链表中,在外部进行处理
				
			|-->else
				|-->rev->handler //(ngx_epoll_module.c)该回调函数在不同阶段被赋予不同的处理函数
					|-->case ngx_event_accept //(ngx_event_accept.c)从listen状态接收到的新连接socket，准备accept

					|-->case ngx_stream_init_connection //(ngx_stream_handler.c) tcp/udp负载均衡
															
					|-->case ngx_http_wait_request_handler //(ngx_http_request.c) accept后的socket数据处理
							
					|-->case ngx_http_process_request_line //(ngx_http_request.c) 处理数据行

		|-->wev = c->write
		|-->if ((revents & EPOLLOUT) && wev->active)
			|-->wev->ready = 1
			|-->if (flags & NGX_POST_EVENTS)
				|-->ngx_post_event(wev, &ngx_posted_events) //见数据插入链表,在外部进行处理
				
			|-->else
				|-->wev->handler //处理可写事件

|-->ngx_event_process_posted //(ngx_event_posted.c) 具体的事件处理, 其内部处理流程常见下面的函数梳理
	|-->while (!ngx_queue_empty(posted)) //根据传入的queue链表进行循环处理(如果其内部不为空的话)
		|-->ngx_queue_head(posted)//获取head头节点
		|-->ngx_queue_data(q, ngx_event_t, queue) //获取当前节点
		|-->ngx_delete_posted_event(ev) //将该节点从链表中删除
		|-->ev->handler(ev) //执行回调函数, 该回调函数就是ngx_post_event中加入的数据
			|-->switch(posted)
				|-->case "ngx_posted_accept_events": //处理可读事件
					|-->case ngx_event_accept //(ngx_event_accept.c)从listen状态接收到的新连接socket，准备accept

                    |-->case ngx_http_wait_request_handler //(ngx_http_request.c) accept后的socket数据处理

                    |-->case ngx_http_process_request_line //(ngx_http_request.c) 处理数据行

				|-->case "ngx_posted_events": //处理可写事件


|-->ngx_event_expire_timers //(ngx_event_timer.c) 时间处理函数
	|-->sentinel = ngx_event_timer_rbtree.sentinel
	|-->for ( ;; )
		|-->root = ngx_event_timer_rbtree.root
		|-->if (root == sentinel)
			|-->return

		|-->node = ngx_rbtree_min(root, sentinel)
		|-->if ((ngx_msec_int_t) (node->key - ngx_current_msec) > 0)
			|-->return

		|-->ev = (ngx_event_t *) ((char *) node - offsetof(ngx_event_t, timer))
		|-->ngx_rbtree_delete(&ngx_event_timer_rbtree, &ev->timer)
		|-->ev->timer_set = 0
		|-->ev->timedout = 1
		|-->ev->handler(ev) //定时器列表的回调函数, 处理通过ngx_add_timer添加的队列

|-->ngx_epoll_eventfd_handler //(ngx_epoll_module.c)
	|-->epoll_ctl
	
|-->ngx_epoll_add_connection //(ngx_epoll_module.c)

|-->ngx_epoll_del_connection //

|-->ngx_epoll_del_event //

|-->ngx_event_core_init_conf //(ngx_event.c)

|-->ngx_conf_parse //(ngx_conf_file.c) 参数解析函数，用于解析nginx的配置文件及传入参数
	|-->ngx_conf_handler //(ngx_conf_file.c)
		|-->ngx_events_block //(ngx_event.c)
			|-->for (i = 0; cf->cycle->modules[i]; i++)
				|-->if (cf->cycle->modules[i]->type != NGX_EVENT_MODULE)
					|-->continue
		
				|-->m = cf->cycle->modules[i]->ctx
				|-->if (m->create_conf)
					|-->m->create_conf //()
		
			|-->ngx_conf_parse//
		
			|-->for (i = 0; cf->cycle->modules[i]; i++)
				|-->if (cf->cycle->modules[i]->type != NGX_EVENT_MODULE)
					|-->continue
		
				|-->m = cf->cycle->modules[i]->ctx
				|-->if (m->init_conf)
					|-->m->init_conf //(ngx_event.c)
		

|-->ngx_event_process_init //(ngx_event.c) event模块的初始化函数,根据不同的分类进行子模块的初始化工作和一些绑定关系的设置
	|-->if(ccf->master && ccf->worker_processes > 1 && ecf->accept_mutex) //ecf->accept_mutex默认为0不会进入该分支
		|-->ngx_use_accept_mutex = 1
		|-->ngx_accept_mutex_held = 0
		|-->ngx_accept_mutex_delay = ecf->accept_mutex_delay
	|-->else //默认配置下进入该分支
		|-->ngx_use_accept_mutex = 0 //默认情况下该值为0,在后面需要用到
	
	|-->ngx_queue_init(&ngx_posted_accept_events) //初始化链表,在后续的处理中需要用到,用来处理read事件
	|-->ngx_queue_init(&ngx_posted_events) //初始化链表,用来处理write事件
	|-->for (m = 0; cycle->modules[m]; m++)
		|-->if (cycle->modules[m]->type != NGX_EVENT_MODULE)
			|-->continue

		|-->if (cycle->modules[m]->ctx_index != ecf->use)
			|-->continue

		|-->module = cycle->modules[m]->ctx
		|-->module->actions.init //(ngx_event.c) 调用回调函数
			|-->ngx_epoll_init //(ngx_epoll_module.c) 调用epoll模块的init回调函, 具体实现参见函数说明

	|-->cycle->connections = ngx_alloc //预分配worker_connections个ngx_connection_t结构体空间
	|-->c = cycle->connections
	|-->cycle->read_events = ngx_alloc //预分配worker_connections个ngx_connection_t结构体空间
	|-->rev = cycle->read_events
	|-->for (i = 0; i < cycle->connection_n; i++)
		|-->rev[i].closed = 1
		|-->rev[i].instance = 1
	
	|-->cycle->write_events = ngx_alloc //预分配worker_connections个ngx_connection_t结构体空间
	|-->wev = cycle->write_events
	|-->for (i = 0; i < cycle->connection_n; i++)
		|-->wev[i].closed = 1

	|-->next = NULL
	|-->i = cycle->connection_n 
	|-->do 
		|-->i--
		|-->c[i].data = next
		|-->c[i].read = &cycle->read_events[i]
		|-->c[i].write = &cycle->write_events[i]
		|-->c[i].fd = (ngx_socket_t) -1
		|-->next = &c[i]
	|-->while(i)//对connections进行初始化,倒序初始化可以避免next初始化需要多写一行代码,写法很精妙 

	|-->cycle->free_connections = next //对free_connections进行初始化, 见用于ngx_get_connection获取空闲的空间
	|-->cycle->free_connection_n = cycle->connection_n 
					
	|-->for (i = 0; i < cycle->listening.nelts; i++)
		|-->if (ls[i].reuseport && ls[i].worker != ngx_worker) //是否开启SO_REUSEPORT功能,该功能需要kernel 3.9版本
			|-->continue; //如果设置了该功能kernel会为每个listen分配独立的hansh table,不再需要锁

		|-->c = ngx_get_connection(ls[i].fd, cycle->log) //(ngx_connection.c) 从链表中获取指针
		|-->rev->accept = 1 //该值用于判断recv到底是有那个链表, ngx_posted_accept_events, ngx_posted_events
		|-->switch(c->type) //设置rev的处理函数,根据协议类型选择(tcp, udp)
			|-->case SOCK_STREAM:
				|-->rev->handler = ngx_event_accept //tcp协议的初始化函数函数

			|-->default:
				|-->rev->handler = ngx_event_recvmsg //udp协议的初始化函数 

		|-->if (ls[i].reuseport) //是否开启SO_REUSEPORT
			|-->ngx_add_event(rev, NGX_READ_EVENT, 0)

		|-->if (ngx_use_accept_mutex)
			|-->continue;

		|-->if ((ngx_event_flags & NGX_USE_EPOLL_EVENT) && ccf->worker_processes > 1) 
			|-->ngx_add_event(rev, NGX_READ_EVENT, NGX_EXCLUSIVE_EVENT) //如果开启了NGX_HAVE_EPOLLEXCLUSIVE宏则进行设置 
			|-->continue //设置后直接跳过不再进入下一步设置,避免重复添加event事件 

		|-->ngx_add_event(rev, NGX_READ_EVENT, 0)//最终调用epoll_ctl加入相应的事件监听, 其实现参见函数说明

|-->ngx_get_connection //(ngx_connection.c) 从链表中获取指定的指针
	|-->c = ngx_cycle->free_connections //从free_connections链表获取
	|-->if (c == NULL) //如果free_connections链表为空
		|-->ngx_drain_connections //(ngx_connection.c)
			|-->for (i = 0; i < n; i++)
				|-->if (ngx_queue_empty(&cycle->reusable_connections_queue))
					|-->break;

				|-->q = ngx_queue_last(&cycle->reusable_connections_queue)
				|-->c = ngx_queue_data(q, ngx_connection_t, queue) //获取节点
				|-->c->close = 1
				|-->c->read->handler(c->read)

		|-->c = ngx_cycle->free_connections //再次进行赋值

	|-->if (c == NULL) //再次进行判断,如果依然为空则返回null
		|-->return NULL

	|-->ngx_cycle->free_connections = c->data //指向下一个节点
	|-->ngx_cycle->free_connection_n-- //对剩余节点数做减一处理
	|-->rev = c->read //保存read事件链表地址
	|-->wev = c->write //保存write事件链表地址
	|-->ngx_memzero(c, sizeof(ngx_connection_t)) //清空该结构体指针的空间
	|-->c->read = rev //重新赋值
	|-->c->write = wev //重新赋值
	|-->c->fd = s //将传入的socket句柄赋值给fd
	|-->c->log = log //将传入的log指针赋值给log
	|-->instance = rev->instance //
	|-->清空rev, wev指针
	|-->将rev, wev的instance 设置为 !instance
	|-->将rev, wev的data 设置为c
	|-->wev->write = 1
	|-->return c //返回一个connections指针


|-->ngx_event_accept //(ngx_event_accept.c)处理accept事件,并设置下一阶段的handler处理函数
	|-->c->recv = ngx_recv //设置回调函数绑定
	|-->c->send = ngx_send //设置回调函数绑定
	|-->do{
		|-->s = accept4/accpet //接收新连接的socket 
		|-->c = ngx_get_connection(s, ev->log) //获取空闲的connection节点
		|-->ls->handler //(ngx_event_accept.c)
			|-->ngx_http_init_connection //(ngx_http_request.c)
				|-->rev->handler = ngx_http_wait_request_handler // 设置可读回调函数	
				|-->c->write->handler = ngx_http_empty_handler // 设置可写的回调函数
				|-->if (rev->ready) //可读
					|-->rev->handler //(ngx_event_accept.c) 执行回调函数 
						|-->ngx_http_wait_request_handler //如果上面有可读事件则调用该函数

					|-->return //退出函数

				|-->ngx_add_timer(rev, c->listening->post_accept_timeout) //
				|-->ngx_reusable_connection(c, 1) //将c插入到reuse链表中,达到重复利用
				|-->ngx_handle_read_event(rev, 0) //(ngx_event.c) 添加到可读事件中
					|-->if (ngx_event_flags & NGX_USE_CLEAR_EVENT) //epoll会进入到该分支,在epoll_init你们进行设置
						|-->if (!rev->active && !rev->ready)
							|-->ngx_add_event(rev, NGX_READ_EVENT, NGX_CLEAR_EVENT) //添加事件

	|-->while(ev->available)//do while循环


|-->ngx_http_wait_request_handler //(ngx_http_request.c) accpet后下一阶段的数据处理函数
	|-->n = c->recv(c, b->last, size) //接收数据
		|-->ngx_recv //(ngx_event.h)
			|-->ngx_io.recv //(ngx_event.h) 在epoll_init里面将ngx_io设置为 ngx_os_io
				|-->ngx_unix_recv //(ngx_recv.c) 使用recv接收数据
				
	|-->ngx_reusable_connection(c, 0) //
	|-->rev->handler = ngx_http_process_request_line //设置新的回调函数，进入下一个状态
	|-->ngx_http_process_request_line //(ngx_http_request.c)
		|-->if (rev->timedout) //如果超时
			|-->c->timedout = 1
			|-->ngx_http_close_request(r, NGX_HTTP_REQUEST_TIME_OUT)
			|-->return

		|-->rc = NGX_AGAIN
		|-->for(;;)//循环接收处理数据
			|-->if (rc == NGX_AGAIN) //第一次进入时会进入该分支
				|-->ngx_http_read_request_header //(ngx_http_request.c)
					|-->if (rev->ready) //如果已经准备好,则直接接收处理
						|-->n = c->recv //接收处理,参考上面的流程分析
						|-->return n;

			|-->ngx_http_parse_request_line //(ngx_http_parse.c) 对接收到的数据进行解析
			|-->if (rc == NGX_OK) //如果解析正确
				|-->c->log->action = "reading client request headers"
				|-->rev->handler = ngx_http_process_request_headers //
				|-->ngx_http_process_request_headers //(ngx_http_request.c)
					|-->if (rev->timedout)
						|-->c->timedout = 1
						|-->ngx_http_close_request(r, NGX_HTTP_REQUEST_TIME_OUT);
						|-->return;

					|-->

				|-->return;

			|-->if (rc != NGX_AGAIN) //不等于初始化
				|-->ngx_http_finalize_request //(ngx_http_request.c)根据解析的返回值惊喜错误码处理
					|-->if (rc >= NGX_HTTP_SPECIAL_RESPONSE)
						|-->ngx_http_special_response_handler //(ngx_http_special_response.c)
							|-->ngx_http_send_error_page //(ngx_http_special_response.c)
								|-->ngx_http_send_special_response //(ngx_http_special_response.c)
						
							|-->ngx_http_send_special_response //(ngx_http_special_response.c)

				|-->return 

|-->ngx_http_memcached_pass //(ngx_http_memcached_module.c)	配置文件中中memcached_pass字段的处理函数
	|-->clcf->handler = ngx_http_memcached_handler //(ngx_http_memcached_module.c)
	
|-->ngx_http_update_location_config //(ngx_http_core_module.c)
	|-->if (clcf->handler)
		|-->r->content_handler = clcf->handler //函数指针赋值,memcached是ngx_http_memcached_handler
	
|-->ngx_http_internal_redirect //(ngx_http_core_module.c)
	|-->ngx_http_update_location_config //(ngx_http_core_module.c)
	|-->ngx_http_handler //()
	
|-->ngx_http_named_location //(ngx_http_core_module.c)
	|-->ngx_http_update_location_config //
	|-->r->phase_handler = cmcf->phase_engine.location_rewrite_index
	|-->r->write_event_handler = ngx_http_core_run_phases
	|-->ngx_http_core_run_phases
	|-->return

	
|-->ngx_http_update_location_config //(ngx_http_core_module.c)
				
|-->ngx_http_process_request_headers //(ngx_http_request.c) 头部数据解析
	|-->ngx_http_get_module_srv_conf //
	|-->ngx_http_parse_header_line //
	|-->ngx_list_push
	|-->ngx_hash_find
	|-->ngx_http_process_request //(ngx_http_request.c)
		|-->c->read->handler = ngx_http_request_handler
		|-->c->write->handler = ngx_http_request_handler
		|-->r->read_event_handler = ngx_http_block_reading
		|-->ngx_http_handler //(ngx_http_core_module.c)
			|-->r->write_event_handler = ngx_http_core_run_phases
			|-->ngx_http_core_run_phases //(ngx_http_core_module.c)
				|-->while (ph[r->phase_handler].checker)
					|-->ph[r->phase_handler].checker() //执行checker回调函数
						|-->ngx_http_core_content_phase //(ngx_http_core_module.c)
							|-->if (r->content_handler)
								|-->r->write_event_handler = ngx_http_request_empty_handler
								|-->ngx_http_finalize_request(r, r->content_handler(r)) 
									|-->r->content_handler(r) //调用回调函数content_handler
										|-->ngx_http_memcached_handler //(ngx_http_memcached_module.c)
								
								|-->return NGX_OK
		
		|-->ngx_http_run_posted_requests //(ngx_http_request.c)
			|-->r->write_event_handler //(ngx_http_request.c)
				|-->

|-->ngx_http_memcached_handler //(ngx_http_memcached_module.c)
	|-->ngx_http_discard_request_body //
	|-->ngx_http_set_content_type //
	|-->ngx_http_upstream_create //
	|-->u->create_request = ngx_http_memcached_create_request
	|-->u->reinit_request = ngx_http_memcached_reinit_request
	|-->u->process_header = ngx_http_memcached_process_header
	|-->u->abort_request = ngx_http_memcached_abort_request
	|-->u->finalize_request = ngx_http_memcached_finalize_request
	|-->ngx_http_set_ctx(r, ctx, ngx_http_memcached_module)
	|-->u->input_filter_init = ngx_http_memcached_filter_init
	|-->u->input_filter = ngx_http_memcached_filter
	|-->ngx_http_upstream_init //(ngx_http_upstream.c)
	
|-->ngx_http_upstream_init //(ngx_http_upstream.c)
	|-->ngx_http_upstream_init_request //(ngx_http_upstream.c)
		|-->if (u->conf->cache)
			|-->ngx_http_upstream_cache
			|-->r->write_event_handler = ngx_http_request_empty_handler
			|-->if (rc == NGX_OK)
				|-->ngx_http_upstream_cache_send //(ngx_http_upstream.c)
					|-->u->process_header()
					|-->ngx_http_upstream_process_headers //()
					|-->ngx_http_cache_send //(ngx_http_file_cache.c)
						|-->ngx_http_send_header //
						|-->ngx_http_output_filter //(ngx_http_core_module.c)
							|-->ngx_http_top_body_filter //()
				
				|-->ngx_http_upstream_cache_background_update
				
		|-->u->create_request() //回调函数
			|-->ngx_http_memcached_create_request //(ngx_http_memcached_module.c)
		
		|-->ngx_http_upstream_set_local //
		|-->ngx_http_cleanup_add
		|-->cln->handler = ngx_http_upstream_cleanup
		|-->if (u->resolved->sockaddr)
			|-->ngx_http_upstream_create_round_robin_peer //
			|-->ngx_http_upstream_connect //
			|-->return

		|-->ngx_resolve_start
		|-->ctx->handler = ngx_http_upstream_resolve_handler
		|-->ngx_resolve_name //(ngx_resolver.c)
			|-->ngx_resolve_name_locked //(ngx_resolver.c)
				|-->ctx->handler() //回调函数
					|-->ngx_http_upstream_resolve_handler //(ngx_http_upstream.c)
						|-->ngx_http_upstream_create_round_robin_peer //
						|-->ngx_resolve_name_done //(ngx_resolver.c)
							|-->ngx_resolver_expire //()

						|-->ngx_http_upstream_connect //(ngx_http_upstream.c)
							|-->ngx_event_connect_peer //(ngx_event_connect.c)连接后端服务器
								|-->ngx_socket
								|-->ngx_get_connection 
								|-->ngx_nonblocking
								|-->connect 
								|-->ngx_add_event //
								|-->wev->ready = 1 //

							|-->if (rc == NGX_BUSY) //如果connect连接失败,且错误码为BUSY
								|-->ngx_http_upstream_next(r, u, NGX_HTTP_UPSTREAM_FT_NOLIVE)

							|-->if (rc == NGX_DECLINED)
								|-->ngx_http_upstream_next(r, u, NGX_HTTP_UPSTREAM_FT_ERROR)

							|-->c->write->handler = ngx_http_upstream_handler
							|-->c->read->handler = ngx_http_upstream_handler
							|-->u->write_event_handler = ngx_http_upstream_send_request_handler
							|-->u->read_event_handler = ngx_http_upstream_process_header
							|-->ngx_http_upstream_send_request //(ngx_http_upstream.c)
								|-->ngx_http_upstream_send_request_body //(ngx_http_upstream.c)
									|-->ngx_http_read_unbuffered_request_body //(ngx_http_request_body.c)
										|-->ngx_http_do_read_client_request_body //(ngx_http_request_body.c)
											|-->

								|-->ngx_handle_write_event//

			|-->return
				
|-->ngx_http_finalize_request //(ngx_http_request.c)
	|-->r->read_event_handler = ngx_http_block_reading
	|-->r->write_event_handler = ngx_http_request_empty_handler
	|-->ngx_http_post_action //(ngx_http_request.c)
		|-->r->read_event_handler = ngx_http_block_reading
		|-->if (clcf->post_action.data[0] == '/')
			|-->ngx_http_internal_redirect //(ngx_http_core_module.c)
		|-->else
			|-->ngx_http_named_location //(ngx_http_core_module.c)

	|-->ngx_http_finalize_connection //(ngx_http_request.c)
				
|-->ngx_reusable_connection //(ngx_connection.c) reusable_connection链表的处理
	|-->if (c->reusable)
		|-->ngx_queue_remove(&c->queue)
		|-->ngx_cycle->reusable_connections_n--

	|-->c->reusable = reusable
	|-->if (reusable)
		|-->ngx_queue_insert_head(
            (ngx_queue_t *) &ngx_cycle->reusable_connections_queue, &c->queue)
		|-->ngx_cycle->reusable_connections_n++


|-->ngx_epoll_init //(ngx_epoll_module.c) 调用epoll模块的初始化函数
	|-->ngx_event_get_conf(cycle->conf_ctx, ngx_epoll_module) //(ngx_event.h) 关联ngx_epoll_module模块
	
	|-->if (ep == -1) //第一次进入时ep=-1，创建epoll后该值将不等于-1
		|-->ep = epoll_create(cycle->connection_n / 2) //创建epoll
		
		|-->ngx_epoll_notify_init //(ngx_epoll_module.c) //(ngx_epoll_module.c)
			|-->notify_fd = eventfd(0, 0) //创建eventfd，用于通知消息
			|-->notify_event.handler = ngx_epoll_notify_handler //设置handler回调函数
			|-->notify_event.active = 1
			|-->notify_conn.fd = notify_fd
			|-->ee.events = EPOLLIN|EPOLLET
			|-->epoll_ctl(ep, EPOLL_CTL_ADD, notify_fd, &ee) //将notify_fd加入到epoll队列中
	
		|-->ngx_epoll_aio_init //(ngx_epoll_module.c) //默认不调用该函数，因为NGX_HAVE_FILE_AIO宏未定义
		
		|-->ngx_epoll_test_rdhup //(ngx_epoll_module.c)
		
		|-->ngx_io = ngx_os_io //设置全局变量，用于io操作(socket接收，发送等)
		|-->ngx_event_actions = ngx_epoll_module_ctx.actions //设置全局变量，回调函数设置，后面需要用到(按模块功能划分)
		|-->ngx_event_flags = NGX_USE_CLEAR_EVENT //在可读事件添加时需要用到这个flag变量
		

|-->ngx_add_event //(ngx_event.h) 事件添加处理
	|-->ngx_event_actions.add //使用ngx_event_actions的add回调函数
		|-->ngx_epoll_add_event //(ngx_epoll_module.c)
			|-->if (e->active) //根据active来设置op操作, 是EPOLL_CTL_MOD还是EPOLL_CTL_ADD
				|-->op = EPOLL_CTL_MOD //如果该值被设置说明已经添加了,需要将其设置为modify,以免重复添加
			|-->else //active = 0
				|-->op = EPOLL_CTL_ADD //说明该fd是第一次加入,将其设置add操作

			|-->epoll_ctl //添加事件
			|-->ev->active = 1 //设置变量,以判断后续加入时是否为第一次加入


|-->ngx_http_file_cache_reopen //

|-->ngx_http_upstream_init_request //()
|-->ngx_http_upstream_cache //

|-->ngx_http_file_cache_open //(ngx_http_file_cache.c)
	|-->ngx_http_file_cache_read //(ngx_http_file_cache.c)
		|-->ngx_http_file_cache_aio_read //(ngx_http_file_cache.c)
			|-->ngx_http_cache_thread_handler //(ngx_thread_pool.c)
				|-->task->event.data = r
				|-->task->event.handler = ngx_http_cache_thread_event_handler
				|-->ngx_thread_task_post //(ngx_thread_pool.c)
					|-->task->event.active = 1
					|-->task->id = ngx_thread_pool_task_id++
					|-->task->next = NULL
					|-->ngx_thread_cond_signal(&tp->cond, tp->log) //发送条件变量
					|-->*tp->queue.last = task
					|-->tp->queue.last = &task->next
					|-->tp->waiting++
					
			|-->ngx_read_file 

		
|-->ngx_http_upstream_server //() NGX_HTTP_MODULE

|-->ngx_thread_pool_init_worker //(ngx_thread_pool.c) 线程池初始化
	|-->ngx_thread_pool_queue_init(&ngx_thread_pool_done) //初始化ngx_thread_pool_done
	
	|-->for (i = 0; i < tcf->pools.nelts; i++) //根据定义的线程池个数进行初始化
		|-->ngx_thread_pool_queue_init(&tp->queue) //
		|-->ngx_thread_mutex_create(&tp->mtx, log) //
		|-->ngx_thread_cond_create(&tp->cond, log) //
		|-->ngx_thread_pool_init //(ngx_thread_pool.c)
			|-->for (n = 0; n < tp->threads; n++) //当前线程池内的线程个数
				|-->pthread_create(&tid, &attr, ngx_thread_pool_cycle, tp) //创建运行线程 ngx_thread_pool_cycle
				

|-->ngx_thread_pool_cycle //(ngx_thread_pool.c) 线程池的工作线程
	|-->for ( ;; )
		|-->ngx_thread_mutex_lock(&tp->mtx, tp->log) 
		|-->tp->waiting--
		|-->while (tp->queue.first == NULL)
			|-->ngx_thread_cond_wait(&tp->cond, &tp->mtx, tp->log) //等待条件变量
			
		|-->task->handler(task->ctx, tp->log) //调用函数
		|-->ngx_notify(ngx_thread_pool_handler) //
			|-->ngx_event_actions.notify //回调函数，实际执行的是 ngx_epoll_notify
				|-->ngx_epoll_notify //(ngx_epoll_module.c)
					|-->static uint64_t inc = 1
					|-->notify_event.data = handler //将 ngx_thread_pool_handler 赋值到 data
					|-->write(notify_fd, &inc, sizeof(uint64_t) //向notify_fd写入参数以触发其监听函数，监听函数为ngx_epoll_notify_init中初始化的 ngx_epoll_notify_handler

					
|-->ngx_epoll_notify_handler //(ngx_epoll_module.c) 线程池中通知处理函数
	|-->if (++ev->index == NGX_MAX_UINT32_VALUE)
		|-->n = read(notify_fd, &count, sizeof(uint64_t))
		|-->if ((size_t) n != sizeof(uint64_t))
			|-->ngx_log_error //打印错误log
			
	|-->handler = ev->data //对应ngx_thread_pool_cycle中传入的handler，即 ngx_thread_pool_handler
	|-->handler(ev) //实际调用的函数为 ngx_thread_pool_handler
		|-->ngx_thread_pool_handler //(ngx_thread_pool.c)
			|-->task = ngx_thread_pool_done.first 
			|-->ngx_thread_pool_done.first = NULL
			|-->ngx_thread_pool_done.last = &ngx_thread_pool_done.first
			
			|-->while (task)
				|-->event = &task->event
				|-->task = task->next
				|-->event->complete = 1
				|-->event->active = 0
				|-->event->handler //执行handler回调函数
				
						
|-->ngx_thread_pool_module //(ngx_thread_pool.c)

|-->ngx_thread_pool_add //(ngx_thread_pool.c)

|-->ngx_thread_pool_get //(ngx_thread_pool.c)

|-->ngx_thread_pool_exit_worker //(ngx_thread_pool.c)

|-->ngx_http_core_set_aio //(ngx_http_core_module.c)

ngx_log_debug0(NGX_LOG_DEBUG_HTTP, rev->log, 0,
                   "http process request line")


|-->ngx_http_filter_finalize_request //(ngx_http_special_response.c)

|-->ngx_thread_read //(ngx_files.c)
	|-->task->handler = ngx_thread_read_handler
	
|-->ngx_thread_write_chain_to_file //(ngx_files.c)
	|-->task->handler = ngx_thread_write_chain_to_file_handler
	
	
|-->ngx_linux_sendfile_thread //(ngx_linux_sendfile_chain.c)
	|-->task->handler = ngx_linux_sendfile_thread_handler

|-->ngx_close_accepted_connection //(ngx_event_accept.c)
	|-->ngx_free_connection //(ngx_connection.c)

|-->ngx_http_close_connection //(ngx_http_request.c) 关闭连接,用于释放connection节点
	|-->ngx_close_connection //(ngx_connection.c)
		|-->ngx_free_connection //(ngx_connection.c) //将要释放的指针插入free_connections的头部
			|-->c->data = ngx_cycle->free_connections 
			|-->ngx_cycle->free_connections = c
			|-->ngx_cycle->free_connection_n++

|-->ngx_http_upstream //(ngx_http_upstream.c) 配置文件中"upstream"字段处理函数
	|-->ngx_http_upstream_add //(ngx_http_upstream.c)
		|-->
	
	|-->ctx = ngx_pcalloc 
	|-->ctx->srv_conf = ngx_pcalloc
	|-->ctx->loc_conf = ngx_pcalloc
	|-->for (m = 0; cf->cycle->modules[m]; m++)
		|-->if (module->create_srv_conf)
			|-->module->create_srv_conf(cf)
				|-->
			
		|-->if (module->create_loc_conf)
			|-->mconf = module->create_loc_conf(cf)
			
	|-->ngx_conf_parse
	
|-->ngx_http_upstream_server //(ngx_http_upstream.c) 处理配置文件中"upstream"的子项里面的"server"
	|-->for (i = 2; i < cf->args->nelts; i++)
		|-->


|-->ngx_stream_block //(ngx_stream.c) nginx.conf文件中stream模块处理方法(与http模块并列)
	|-->ngx_stream_max_module = ngx_count_modules(cf->cycle, NGX_STREAM_MODULE) //获取stream模块的个数
	|-->ctx->main_conf = ngx_pcalloc
	|-->ctx->srv_conf = ngx_pcalloc
	|-->for (m = 0; cf->cycle->modules[m]; m++)
		|-->if (cf->cycle->modules[m]->type != NGX_STREAM_MODULE)
			|-->continue;

		|-->if (module->create_main_conf)
			|-->ctx->main_conf[mi] = module->create_main_conf() //调用回调函数
			
		|-->if (module->create_srv_conf)
			|-->ctx->srv_conf[mi] = module->create_srv_conf(cf)

	|-->for (m = 0; cf->cycle->modules[m]; m++)
		|-->if (cf->cycle->modules[m]->type != NGX_STREAM_MODULE)
			|-->continue;

		|-->if (module->preconfiguration)
			|-->module->preconfiguration(cf) //

	|-->ngx_conf_parse //
	|-->for (m = 0; cf->cycle->modules[m]; m++)
		|-->if (cf->cycle->modules[m]->type != NGX_STREAM_MODULE)
			|-->continue;

		|-->if (module->init_main_conf)
			|-->module->init_main_conf()

		|-->for (s = 0; s < cmcf->servers.nelts; s++)
			|-->if (module->merge_srv_conf)
				|-->module->merge_srv_conf()

	|-->ngx_stream_init_phases //
	|-->for (m = 0; cf->cycle->modules[m]; m++)
		|-->if (cf->cycle->modules[m]->type != NGX_STREAM_MODULE)
			|-->continue

		|-->if (module->postconfiguration)
			|-->module->postconfiguration(cf)//

	|-->ngx_stream_variables_init_vars //

	|-->ngx_stream_init_phase_handlers //
	|-->for (i = 0; i < cmcf->listen.nelts; i++)
		|-->ngx_stream_add_ports //

	|-->ngx_stream_optimize_servers //(ngx_stream.c)

|-->ngx_stream_init_phase_handlers //(ngx_stream.c)
	|-->ph = ngx_pcalloc()
	|-->cmcf->phase_engine.handlers = ph
	|-->for (i = 0; i < NGX_STREAM_LOG_PHASE; i++)
		|-->switch (i)
			|-->case NGX_STREAM_PREREAD_PHASE:
				|-->checker = ngx_stream_core_preread_phase

			|-->case NGX_STREAM_CONTENT_PHASE:
				|-->ph->checker = ngx_stream_core_content_phase
				|-->n++; ph++;

			|-->default:
				|-->checker = ngx_stream_core_generic_phase

		|-->n += cmcf->phases[i].handlers.nelts
		|-->for (j = cmcf->phases[i].handlers.nelts - 1; j >= 0; j--)
			|-->ph->checker = checker
			|-->ph->handler = h[j]
			|-->ph->next = n, ph++

|-->ngx_stream_optimize_servers //(ngx_stream.c)
	|-->for (p = 0; p < ports->nelts; p++)
		|-->last = port[p].addrs.nelts
		|-->while(i < last)
			|-->ngx_create_listening //
			|-->ls->handler = ngx_stream_init_connection
			|-->stport = ngx_palloc()
			|-->ngx_stream_add_addrs //
			|-->ngx_clone_listening //

|-->ngx_stream_init_connection //(ngx_stream_handler.c) tcp/udp负载均衡处理函数,如果定义了该函数这在accept后调用该函数
	|-->rev->handler = ngx_stream_session_handler
	|-->if (addr_conf->proxy_protocol)
		|-->rev->handler = ngx_stream_proxy_protocol_handler
		
	|-->if (ngx_use_accept_mutex)
		|-->ngx_post_event(rev, &ngx_posted_events)
		|-->return

	|-->rev->handler() //执行回调函数
		|-->case ngx_stream_proxy_protocol_handler //
		|-->case ngx_stream_session_handler //(ngx_stream_handler.c)
			|-->ngx_stream_core_run_phases //(ngx_stream_core_module.c)
				|-->ph = cmcf->phase_engine.handlers
				|-->while (ph[s->phase_handler].checker) //checker回调函数,其定义在ngx_stream_init_phase_handlers
					|-->rc = ph[s->phase_handler].checker(s, &ph[s->phase_handler]) //checker回调处理函数
						|-->case ngx_stream_core_preread_phase //
						|-->case ngx_stream_core_content_phase //主要处理函数
						|-->case ngx_stream_core_generic_phase //

|-->ngx_stream_proxy_pass //(ngx_stream_proxy_module.c) stream模块定义处理函数
	|-->cscf->handler = ngx_stream_proxy_handler //将在后面的context中进行处理调用
	|-->ngx_stream_compile_complex_value //
	|-->ngx_stream_upstream_add //

|-->ngx_stream_core_content_phase //(ngx_stream_core_module.c)
	|-->cscf = ngx_stream_get_module_srv_conf(s, ngx_stream_core_module)
	|-->cscf->handler(s) //调用回调函数
		|-->ngx_stream_proxy_handler //(ngx_stream_proxy_module.c)

|-->ngx_stream_proxy_handler //(ngx_stream_proxy_module.c) 负载均衡回调函数
	|-->ngx_stream_proxy_set_local //
	|-->c->write->handler = ngx_stream_proxy_downstream_handler //将在ngx_stream_proxy_process中被添加到epoll监听中
	|-->c->read->handler = ngx_stream_proxy_downstream_handler //将在ngx_stream_proxy_process中被添加到epoll监听中
	|-->for (i = 0; i < umcf->upstreams.nelts; i++)
		|-->if found
			goto found;

	|-->if (u->resolved->sockaddr)
		|-->ngx_stream_upstream_create_round_robin_peer //
		|-->ngx_stream_proxy_connect
		|-->return

	|-->ctx = ngx_resolve_start //
	|-->ctx->handler = ngx_stream_proxy_resolve_handler
	|-->ngx_resolve_name
	|-->return

found:
	|-->uscf->peer.init(s, uscf)
		|-->ngx_stream_upstream_init_round_robin_peer //(ngx_stream_upstream_round_robin.c)
			|-->s->upstream->peer.get = ngx_stream_upstream_get_round_robin_peer
			|-->s->upstream->peer.free = ngx_stream_upstream_free_round_robin_peer
			|-->s->upstream->peer.notify = ngx_stream_upstream_notify_round_robin_peer
			|-->s->upstream->peer.tries = ngx_stream_upstream_tries(rrp->peers)

	|-->ngx_stream_proxy_connect //连接后端服务器

|-->ngx_stream_proxy_downstream_handler //(ngx_stream_proxy_module.c) 负载均衡server的接收处理函数
	|-->ngx_stream_proxy_process_connection //负载均衡连接函数
	
|-->ngx_stream_proxy_process_connection //(ngx_stream_proxy_module.c)
	|-->if (c->close)
		|-->ngx_stream_proxy_finalize //关闭连接
		|-->return
		
	|-->if (from_upstream && !u->connected)
		|-->return
		
	|-->ngx_stream_proxy_process(s, from_upstream, ev->write) //
	
|-->ngx_stream_proxy_connect //(ngx_stream_proxy_module.c) 负载均衡选择连接后端服务器
	|-->ngx_event_connect_peer //(ngx_event_connect.c)连接后端服务器 
	|-->pc->read->handler = ngx_stream_proxy_connect_handler 
	|-->pc->write->handler = ngx_stream_proxy_connect_handler
	|-->ngx_add_timer(pc->write, pscf->connect_timeout) //添加到超时处理队列中,最终会在ngx_event_expire_timers中被处理
					
|-->ngx_event_connect_peer //(ngx_event_connect.c)连接后端服务器
	|-->rc = pc->get(pc, pc->data) //回调函数
		|-->ngx_stream_upstream_get_round_robin_peer //对后端服务器进行选择,进行负载均衡处理
			|-->ngx_stream_upstream_get_round_robin_peer //获取对端的连接信息
				
		|-->ngx_socket //创建socket
		|-->ngx_get_connection //
		|-->ngx_nonblocking //设置为非阻塞
		
		|-->if (type == SOCK_STREAM)
			|-->c->recv = ngx_recv
			|-->c->send = ngx_send
			|-->c->recv_chain = ngx_recv_chain
			|-->c->send_chain = ngx_send_chain
			
		|-->ngx_add_conn //添加到可读事件中
			|-->ngx_event_actions.add_conn //添加到epoll监听中
			
		|-->connect //连接对端,由于是非阻塞所以第一次连接可能会失败

|-->ngx_add_timer(pc->write, pscf->connect_timeout) //添加到超时处理队列中
	|-->ngx_event_add_timer //(ngx_event.h)
		|-->ngx_rbtree_insert(&ngx_event_timer_rbtree, &ev->timer)//(ngx_rbtree.c)
			|-->tree->insert(*root, node, sentinel)
			|-->ngx_rbt_black //(ngx_rbtree.h)
				|-->((node)->color = 0)

|-->ngx_stream_proxy_connect_handler //(ngx_stream_proxy_module.c) connect的定时处理函数
	|-->if (ev->timedout) //如果超时
		|-->ngx_stream_proxy_next_upstream //
		|-->return

	|-->ngx_del_timer(c->write) //从定时器队列中删除
	|-->ngx_stream_proxy_test_connect //
	|-->ngx_stream_proxy_init_upstream // proxy负载均衡初始化

|-->ngx_stream_proxy_test_connect //()

|-->ngx_stream_proxy_init_upstream //(ngx_stream_proxy_module.c)
	|-->ngx_tcp_nodelay //
	|-->ngx_connection_local_sockaddr //
	|-->pc->read->handler = ngx_stream_proxy_upstream_handler //
	|-->pc->write->handler = ngx_stream_proxy_upstream_handler //
	
	|-->if (pc->read->ready) //如果read数据已经准备就绪则将其插入到ngx_posted_events队列中
		|-->ngx_post_event(pc->read, &ngx_posted_events)
		
	|-->ngx_stream_proxy_process //proxy处理函数

|-->ngx_stream_proxy_upstream_handler //(ngx_stream_proxy_module.c)
	|-->ngx_stream_proxy_process_connection //(ngx_stream_proxy_module.c)
	
|-->ngx_stream_proxy_process //(ngx_stream_proxy_module.c) 负载均衡处理函数
	|-->u = s->upstream 
	|-->c = s->connection
	|-->pc = u->connected ? u->peer.connection : NULL
	
	|-->if (from_upstream) //来自负载均衡的回复
		|-->src = pc, dst = c, b = &u->upstream_buf, limit_rate = pscf->download_rate
		|-->received = &u->received, packets = &u->responses
		|-->out = &u->downstream_out, busy = &u->downstream_busy
		|-->recv_action = "proxying and reading from upstream"
		|-->send_action = "proxying and sending to client"

	|-->else //发往对端的数据(负载均衡)
		|-->src = c, dst = pc, b = &u->downstream_buf, limit_rate = pscf->upload_rate
		|-->received = &s->received, packets = &u->requests
		|-->out = &u->upstream_out, busy = &u->upstream_busy
		|-->recv_action = "proxying and reading from client"
		|-->send_action = "proxying and sending to upstream"

	|-->for ( ;; )
		|-->if (do_write && dst)
			|-->if (*out || *busy || dst->buffered)
				|-->c->log->action = send_action
				|-->ngx_stream_top_filter(s, *out, from_upstream)//发往对端
				|-->ngx_chain_update_chains //

		|-->if (size && src->read->ready && !src->read->delayed
            && !src->read->error) //有可读事件
			|-->c->log->action = recv_action
			|-->src->recv(src, b->last, size)
			
	|-->ngx_handle_read_event(src->read, flags) //将server的fd添加到epoll的监听队列中
	|-->if (dst)
		|-->ngx_add_timer(c->write, pscf->timeout) //添加到定时器队列中

		
|-->ngx_stream_top_filter //(ngx_stream_write_filter_module.c) 将数据写入对端
	|-->ngx_stream_write_filter //(ngx_stream_write_filter_module.c)
		|-->c->send_chain(c, *out, 0) //调用回调函数
			|-->ngx_send_chain //(ngx_event.h)
				|-->ngx_io.send_chain //(ngx_event.h)
					|-->ngx_writev_chain //(ngx_posix_init.c)
			
|-->ngx_writev_chain //(ngx_posix_init.c) 数据写入模块
	|-->for ( ;; )
		|-->ngx_output_chain_to_iovec //
		|-->ngx_writev(c, &vec) //(ngx_writev_chain.c)
			|-->writev(c->fd, vec->iovs, vec->count) // 写入数据

		|-->ngx_chain_update_sent //

					
|-->ngx_event_timer_init //(ngx_event_timer.c)
	|-->ngx_rbtree_init(&ngx_event_timer_rbtree, &ngx_event_timer_sentinel,
                    ngx_rbtree_insert_timer_value)
		|-->ngx_rbtree_sentinel_init //(ngx_rbtree.h)
			|-->ngx_rbt_black //()

		|-->(tree)->root = s
		|-->(tree)->sentinel = s
		|-->(tree)->insert = i

|-->ngx_stream_upstream //(ngx_stream_upstream.c)
	|-->module->create_srv_conf()
	|-->ngx_conf_parse //
	|-->

|-->ngx_stream_upstream_least_conn //(ngx_stream_upstream_least_conn_module.c)
	|-->uscf->peer.init_upstream = ngx_stream_upstream_init_least_conn //

|-->ngx_stream_upstream_init_least_conn //(ngx_stream_upstream_least_conn_module.c)
	|-->ngx_stream_upstream_init_round_robin //()
	|-->us->peer.init = ngx_stream_upstream_init_least_conn_peer //

|-->ngx_stream_upstream_init_least_conn_peer //(ngx_stream_upstream_least_conn_module.c)
	|-->ngx_stream_upstream_init_round_robin_peer //
	|-->s->upstream->peer.get = ngx_stream_upstream_get_least_conn_peer //

|-->ngx_stream_proxy_protocol_handler //(ngx_stream_handler.c)
	|-->n = recv(c->fd, (char *) buf, sizeof(buf), MSG_PEEK)
	|-->if (rev->timer_set)
		|-->ngx_del_timer

	|-->p = ngx_proxy_protocol_read()
	|-->ngx_stream_session_handler //()

|-->ngx_stream_session_handler //(ngx_stream_handler.c)
	|-->c = rev->data
	|-->s = c->data
	|-->ngx_stream_core_run_phases(s)

|-->ngx_stream_core_preread_phase //(ngx_stream_core_module.c)
	|-->rc = ph->handler(s) //
		|-->ngx_stream_limit_conn_handler //()

	|-->ngx_stream_finalize_session //()

|-->ngx_stream_core_generic_phase //(ngx_stream_core_module.c)
	
|-->ngx_stream_upstream_update_random //(ngx_stream_upstream_random_module.c)	
	|-->ngx_alloc //(ngx_alloc.c) 内存分配

|-->ngx_stream_proxy_finalize //(ngx_stream_proxy_module.c)
	|-->if (u->peer.free && u->peer.sockaddr) //如果定义了free函数且存在地址则释放其内存
		|-->u->peer.free() //调用free回调函数
			|-->ngx_stream_upstream_free_round_robin_peer //() 实际的处理函数
		
		|-->u->peer.sockaddr = NULL

	|-->if(pc)
		|-->ngx_close_connection(pc) //close 相应的socket数据
		|-->u->peer.connection = NULL

	|-->ngx_stream_finalize_session //session最终销毁处理函数
	
|-->ngx_stream_finalize_session //(ngx_stream_handler.c)
	|-->ngx_stream_log_session //
	|-->ngx_stream_close_connection //
