|-----------------------重要数据结构-------------------------------------

|-->typedef struct ngx_module_s          ngx_module_t
|-->typedef struct ngx_conf_s            ngx_conf_t
|-->typedef struct ngx_cycle_s           ngx_cycle_t
|-->typedef struct ngx_pool_s            ngx_pool_t
|-->typedef struct ngx_chain_s           ngx_chain_t
|-->typedef struct ngx_log_s             ngx_log_t
|-->typedef struct ngx_open_file_s       ngx_open_file_t
|-->typedef struct ngx_command_s         ngx_command_t
|-->typedef struct ngx_file_s            ngx_file_t
|-->typedef struct ngx_event_s           ngx_event_t
|-->typedef struct ngx_event_aio_s       ngx_event_aio_t
|-->typedef struct ngx_connection_s      ngx_connection_t
|-->typedef struct ngx_thread_task_s     ngx_thread_task_t
|-->typedef struct ngx_ssl_s             ngx_ssl_t
|-->typedef struct ngx_ssl_connection_s  ngx_ssl_connection_t
|-->typedef struct ngx_udp_connection_s  ngx_udp_connection_t
|-->typedef u_char *(*ngx_log_handler_pt) (ngx_log_t *log, u_char *buf, size_t len)
|-->typedef void (*ngx_log_writer_pt) (ngx_log_t *log, ngx_uint_t level, u_char *buf, size_t len)
|-->#define NGX_ERROR_LOG_PATH  "logs/error.log"


|-->log文件操作数据结构体ngx_open_file_s //(ngx_conf_file.h)
	|-->struct ngx_open_file_s {
		ngx_fd_t              fd;
		ngx_str_t             name;

		void                (*flush)(ngx_open_file_t *file, ngx_log_t *log); //flush函数指针
		void                 *data;
	};


|-->log数据结构体ngx_log_s //(ngx_log.h)
	|-->struct ngx_log_s {
		ngx_uint_t           log_level;  
		ngx_open_file_t     *file;       

		ngx_atomic_uint_t    connection; 

		time_t               disk_full_time;

		ngx_log_handler_pt   handler; //函数指针 指针 
		void                *data;       

		ngx_log_writer_pt    writer;     
		void                *wdata;

		/*
		 * we declare "action" as "char *" because the actions are usually
		 * the static strings and in the "u_char *" case we have to override
		 * their types all the time
		 */ 

		char                *action;

		ngx_log_t           *next;
	};


|-->ngx_cycle数据结构体ngx_cycle_s //(ngx_cycle.h)
	|-->struct ngx_cycle_s {
		void                  ****conf_ctx;
		ngx_pool_t               *pool;

		ngx_log_t                *log;
		ngx_log_t                 new_log;

		ngx_uint_t                log_use_stderr;  /* unsigned  log_use_stderr:1; */

		ngx_connection_t        **files;
		ngx_connection_t         *free_connections;
		ngx_uint_t                free_connection_n;

		ngx_module_t            **modules;
		ngx_uint_t                modules_n;
		ngx_uint_t                modules_used;    /* unsigned  modules_used:1; */

		ngx_queue_t               reusable_connections_queue;
		ngx_uint_t                reusable_connections_n;

		ngx_array_t               listening;
		ngx_array_t               paths;

		ngx_array_t               config_dump;
		ngx_rbtree_t              config_dump_rbtree;
		ngx_rbtree_node_t         config_dump_sentinel;

		ngx_list_t                open_files;
		ngx_list_t                shared_memory;

		ngx_uint_t                connection_n;
		ngx_uint_t                files_n;
		ngx_connection_t         *connections;
		ngx_event_t              *read_events;
		ngx_event_t              *write_events;

		ngx_cycle_t              *old_cycle;

		ngx_str_t                 conf_file;
		ngx_str_t                 conf_param;
		ngx_str_t                 conf_prefix;
		ngx_str_t                 prefix;
		ngx_str_t                 lock_file;
		ngx_str_t                 hostname;
	};

|-->ngx_event_actions事件处理结构体(对应不同清空的执行动作) //(ngx_event.h)
	|-->typedef struct {
		ngx_int_t  (*add)(ngx_event_t *ev, ngx_int_t event, ngx_uint_t flags);
		ngx_int_t  (*del)(ngx_event_t *ev, ngx_int_t event, ngx_uint_t flags);

		ngx_int_t  (*enable)(ngx_event_t *ev, ngx_int_t event, ngx_uint_t flags);
		ngx_int_t  (*disable)(ngx_event_t *ev, ngx_int_t event, ngx_uint_t flags);

		ngx_int_t  (*add_conn)(ngx_connection_t *c);
		ngx_int_t  (*del_conn)(ngx_connection_t *c, ngx_uint_t flags);

		ngx_int_t  (*notify)(ngx_event_handler_pt handler);

		ngx_int_t  (*process_events)(ngx_cycle_t *cycle, ngx_msec_t timer,
									 ngx_uint_t flags);

		ngx_int_t  (*init)(ngx_cycle_t *cycle, ngx_msec_t timer);
		void       (*done)(ngx_cycle_t *cycle);
	} ngx_event_actions_t; 

|-->ngx_event_module事件结构体(包含配置创建和初始化) //(ngx_event.h)
	|-->typedef struct {
		ngx_str_t              *name;        
			
		void                 *(*create_conf)(ngx_cycle_t *cycle);
		char                 *(*init_conf)(ngx_cycle_t *cycle, void *conf);

		ngx_event_actions_t     actions;     
	} ngx_event_module_t;
	
|-->ngx_module module结构体 //(ngx_module.h)
	|-->struct ngx_module_s {
		ngx_uint_t            ctx_index;
		ngx_uint_t            index;

		char                 *name;

		ngx_uint_t            spare0;
		ngx_uint_t            spare1;

		ngx_uint_t            version;
		const char           *signature;

		void                 *ctx;
		ngx_command_t        *commands;
		ngx_uint_t            type;

		ngx_int_t           (*init_master)(ngx_log_t *log);

		ngx_int_t           (*init_module)(ngx_cycle_t *cycle);

		ngx_int_t           (*init_process)(ngx_cycle_t *cycle);
		ngx_int_t           (*init_thread)(ngx_cycle_t *cycle);
		void                (*exit_thread)(ngx_cycle_t *cycle);
		void                (*exit_process)(ngx_cycle_t *cycle);

		void                (*exit_master)(ngx_cycle_t *cycle);

		uintptr_t             spare_hook0;
		uintptr_t             spare_hook1;
		uintptr_t             spare_hook2;
		uintptr_t             spare_hook3;
		uintptr_t             spare_hook4;
		uintptr_t             spare_hook5;
		uintptr_t             spare_hook6;
		uintptr_t             spare_hook7;
	};
	
|-->static ngx_event_module_t  ngx_epoll_module_ctx = {
    &epoll_name,
    ngx_epoll_create_conf,               /* create configuration */
    ngx_epoll_init_conf,                 /* init configuration */

    {
        ngx_epoll_add_event,             /* add an event */
        ngx_epoll_del_event,             /* delete an event */
        ngx_epoll_add_event,             /* enable an event */
        ngx_epoll_del_event,             /* disable an event */
        ngx_epoll_add_connection,        /* add an connection */
        ngx_epoll_del_connection,        /* delete an connection */
#if (NGX_HAVE_EVENTFD)
        ngx_epoll_notify,                /* trigger a notify */
#else
        NULL,                            /* trigger a notify */
#endif
        ngx_epoll_process_events,        /* process the events */
        ngx_epoll_init,                  /* init the events */
        ngx_epoll_done,                  /* done the events */
    }
};

#define NGX_CORE_MODULE      0x45524F43
#define NGX_EVENT_MODULE     0x544E5645

ngx_module_t  ngx_epoll_module = {
    NGX_MODULE_V1,
    &ngx_epoll_module_ctx,               /* module context */
    ngx_epoll_commands,                  /* module directives */
    NGX_EVENT_MODULE,                    /* module type */
    NULL,                                /* init master */
    NULL,                                /* init module */
    NULL,                                /* init process */
    NULL,                                /* init thread */
    NULL,                                /* exit thread */
    NULL,                                /* exit process */
    NULL,                                /* exit master */
    NGX_MODULE_V1_PADDING
};

ngx_module_t  ngx_event_core_module = {
    NGX_MODULE_V1,
    &ngx_event_core_module_ctx,            /* module context */
    ngx_event_core_commands,               /* module directives */
    NGX_EVENT_MODULE,                      /* module type */
    NULL,                                  /* init master */
    ngx_event_module_init,                 /* init module */
    ngx_event_process_init,                /* init process */
    NULL,                                  /* init thread */
    NULL,                                  /* exit thread */
    NULL,                                  /* exit process */
    NULL,                                  /* exit master */
    NGX_MODULE_V1_PADDING
}; //(ngx_event.c) evnet事件的核心定义，其包含epoll结构体的关联

static ngx_event_module_t  ngx_event_core_module_ctx = {
    &event_core_name,
    ngx_event_core_create_conf,            /* create configuration */
    ngx_event_core_init_conf,              /* init configuration */
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL }
};//(ngx_event.c)

|-->command指令集 //(ngx_conf_file.h)
	|-->struct ngx_command_s {
	    ngx_str_t             name;
	    ngx_uint_t            type;
	    char               *(*set)(ngx_conf_t *cf, ngx_command_t *cmd, void *conf);
	    ngx_uint_t            conf;
	    ngx_uint_t            offset;
	    void                 *post;
	};

ngx_module_t *ngx_modules[] = {
    &ngx_core_module,
    &ngx_errlog_module,
    &ngx_conf_module,
    &ngx_regex_module,
    &ngx_events_module,
    &ngx_event_core_module,
    &ngx_epoll_module,
    &ngx_http_module,
    &ngx_http_core_module,
    &ngx_http_log_module,
    &ngx_http_upstream_module,
    &ngx_http_static_module,
    &ngx_http_autoindex_module,
    &ngx_http_index_module,
    &ngx_http_mirror_module,
    &ngx_http_try_files_module,
    &ngx_http_auth_basic_module,
    &ngx_http_access_module,
    &ngx_http_limit_conn_module,
    &ngx_http_limit_req_module,
    &ngx_http_geo_module,
    &ngx_http_map_module,
    &ngx_http_split_clients_module,
    &ngx_http_referer_module,
    &ngx_http_rewrite_module,
    &ngx_http_proxy_module,
    &ngx_http_fastcgi_module,
    &ngx_http_uwsgi_module,
    &ngx_http_scgi_module,
    &ngx_http_memcached_module,
    &ngx_http_empty_gif_module,
    &ngx_http_browser_module,
    &ngx_http_upstream_hash_module,
	&ngx_http_upstream_ip_hash_module,
    &ngx_http_upstream_least_conn_module,
    &ngx_http_upstream_random_module,
    &ngx_http_upstream_keepalive_module,
    &ngx_http_upstream_zone_module,
    &ngx_http_write_filter_module,
    &ngx_http_header_filter_module,
    &ngx_http_chunked_filter_module,
    &ngx_http_range_header_filter_module,
    &ngx_http_gzip_filter_module,
    &ngx_http_postpone_filter_module,
    &ngx_http_ssi_filter_module,
    &ngx_http_charset_filter_module,
    &ngx_http_userid_filter_module,
    &ngx_http_headers_filter_module,
    &ngx_http_copy_filter_module,
    &ngx_http_range_body_filter_module,
    &ngx_http_not_modified_filter_module,
    NULL
}; //(objs/ngx_modules.c) 所有module的集合

|-->ngx_process_events_and_timers //(ngx_event.c) 处理不同的事件
	|-->ngx_trylock_accept_mutex //(ngx_event_accept.c)
		|-->ngx_shmtx_trylock //()
		|-->

	|-->ngx_process_events(cycle, timer, flags) //实际调用ngx_epoll_process_events函数开始处理
		|-->ngx_epoll_process_events //(ngx_epoll_module.c)
			|-->epoll_wait //(ngx_process_events.c)


|-->main //(nginx.c) nginx函数入口
	|-->ngx_max_sockets = -1 
	|-->ngx_time_init //
	|-->ngx_regex_init //默认NGX_PCRE为true
	|-->ngx_log_init //(ngx_log.c)
		|-->ngx_log.file = &ngx_log_file 
		|-->ngx_log.log_level = NGX_LOG_NOTICE //设置打印等级
		|-->name = (u_char *) NGX_ERROR_LOG_PATH //获取文件名称
		|-->ngx_log_file.fd = ngx_open_file(name, NGX_FILE_APPEND,
                                    NGX_FILE_CREATE_OR_OPEN,
                                    NGX_FILE_DEFAULT_ACCESS) //打开文件, 当文件不存在时创建文件
									
		|-->return &ngx_log //返回ngx_log的地址
		
	|-->ngx_memzero(&init_cycle, sizeof(ngx_cycle_t)) //清空init_cycle
	|-->init_cycle.log = log //将ngx_log的地址赋值给init_cycle.log
	|-->ngx_cycle = &init_cycle //
	
	|-->init_cycle.pool = ngx_create_pool //
	
	|-->ngx_process_options //
	
	|-->ngx_os_init //
	
	|-->ngx_crc32_table_init //
	
	|-->ngx_slab_sizes_init //
	
	|-->ngx_add_inherited_sockets //
	
	|-->ngx_preinit_modules //(ngx_module.c)
		|-->for (i = 0; ngx_modules[i]; i++) //获取
			|-->ngx_modules[i]->index = i;
			|-->ngx_modules[i]->name = ngx_module_names[i];

		|-->ngx_modules_n = i //统计当前的module数量，用于后面的拷贝复制
		|-->ngx_max_module = ngx_modules_n + NGX_MAX_DYNAMIC_MODULES
	
	|-->ngx_init_cycle //(ngx_cycle.c)
		|-->ngx_cycle_modules //(ngx_module.c)
			|-->cycle->modules = ngx_pcalloc(cycle->pool, (ngx_max_module + 1) * sizeof(ngx_module_t *)) //分配空间
			|-->ngx_memcpy(cycle->modules, ngx_modules, ngx_modules_n * sizeof(ngx_module_t *)) //将全局module拷贝到cycle->modules
			|-->cycle->modules_n = ngx_modules_n //当前module的数量
		
		|-->for (i = 0; cycle->modules[i]; i++) //对modules进行轮训判断其type值
			|-->if (cycle->modules[i]->type != NGX_CORE_MODULE) //对modules进行轮训判断其type值
				|-->continue //只要type=NGX_CORE_MODULE的module
			
			|-->module = cycle->modules[i]->ctx //获取结构体中ngx_event_module_t成员, 本次分析以ngx_event_core_module_ctx为例子
			|-->if (module->create_conf) //如果create_conf回调函数存在则调用回调
				module->create_conf //调用回调函数，ngx_event_core_module_ctx中ngx_event_core_create_conf
					|-->ngx_event_core_create_conf //(ngx_event.c)
						|-->
		
		|-->conf.module_type = NGX_CORE_MODULE
		|-->conf.cmd_type = NGX_MAIN_CONF

		|-->ngx_conf_param //(ngx_conf_file.c)
			|-->conf_file.file.fd = NGX_INVALID_FILE
			|-->conf_file.file.name.data = NULL
			|-->conf_file.line = 0
			|-->cf->conf_file = &conf_file
			|-->ngx_conf_parse(cf, NULL) //(ngx_conf_file.c)

		|-->for (i = 0; cycle->modules[i]; i++) //对全局modules指针数组进行轮巡
			|-->if (cycle->modules[i]->type != NGX_CORE_MODULE)
				|-->continue //只要type=NGX_CORE_MODULE的module
				
			|-->module = cycle->modules[i]->ctx 
			|-->if (module->init_conf) //如果create_conf回调函数存在则调用回调
				|-->module->init_conf //调用回调函数，ngx_event_core_module_ctx中 ngx_event_core_init_conf
					|-->ngx_event_core_init_conf //(ngx_event.c)
						|-->fd = epoll_create(100)
						|-->module = &ngx_epoll_module //在linux下默认连接这个, 开始关联上epoll操作
						|-->ngx_conf_init_uint_value //()
			
		|-->ngx_open_listening_sockets //(ngx_connection.c)
		|-->if (!ngx_test_config)			
			|-->ngx_configure_listening_sockets //(ngx_connection.c)

	|-->if (ngx_process == NGX_PROCESS_SINGLE)
		|-->ngx_single_process_cycle
	
	|-->else //当ngx_process不等于NGX_PROCESS_SINGLE时进入该分支
		|-->ngx_master_process_cycle //(ngx_process_cycle.c)
			|-->ngx_init_cycle //(ngx_cycle.c)
			|-->ngx_start_worker_processes //(ngx_process_cycle.c)
				|-->ngx_worker_process_cycle //(ngx_process_cycle.c)
					|-->for (i = 0; cycle->modules[i]; i++) 
						|-->if (cycle->modules[i]->init_process)
							|-->cycle->modules[i]->init_process(cycle) //回调函数
								|-->ngx_worker_process_init //(ngx_process_cycle.c)
									|-->ngx_event_process_init //(ngx_event.c)
										|-->for (m = 0; cycle->modules[m]; m++)
											|-->if (cycle->modules[m]->type != NGX_EVENT_MODULE)
												|-->continue
									
											|-->if (cycle->modules[m]->ctx_index != ecf->use)
												|-->continue
									
											|-->module = cycle->modules[m]->ctx
											|-->module->actions.init //(ngx_event.c) 调用回调函数
												|-->ngx_epoll_init //(ngx_epoll_module.c) 调用epoll模块的init回调函
		
			|-->ngx_start_cache_manager_processes //(ngx_process_cycle.c)
				|-->ngx_cache_manager_process_cycle //(ngx_process_cycle.c)
					
					
					
		|-->ngx_epoll_add_event //(ngx_epoll_module.c)
			|-->epoll_ctl //
			
		|-->ngx_epoll_eventfd_handler //(ngx_epoll_module.c)
			|-->epoll_ctl
			
		|-->ngx_epoll_add_connection //(ngx_epoll_module.c)
		
		|-->ngx_epoll_del_connection //
		
		|-->ngx_epoll_del_event //
		
		|-->ngx_epoll_init //(ngx_epoll_module.c)
			|-->ngx_event_get_conf(cycle->conf_ctx, ngx_epoll_module) //(ngx_event.h) 关联ngx_epoll_module模块
				|-->
			
			|-->ngx_epoll_notify_init //(ngx_epoll_module.c)
			
			|-->ngx_epoll_aio_init //(ngx_epoll_module.c)
				|-->epoll_ctl
				
			|-->ngx_epoll_test_rdhup //(ngx_epoll_module.c)
			
		
		|-->ngx_event_core_init_conf //(ngx_event.c)
		
		|-->ngx_event_process_init //(ngx_event.c)
		
		|-->ngx_conf_parse //(ngx_conf_file.c)
			|-->ngx_conf_handler //(ngx_conf_file.c)
				|-->cmd = cf->cycle->modules[i]->commands //
					|-->
		
		
		|-->ngx_conf_parse //(ngx_conf_file.c)
			|-->ngx_conf_handler //(ngx_conf_file.c)
				|-->ngx_events_block //(ngx_event.c)
					|-->for (i = 0; cf->cycle->modules[i]; i++)
						|-->if (cf->cycle->modules[i]->type != NGX_EVENT_MODULE)
							|-->continue
				
						|-->m = cf->cycle->modules[i]->ctx
						|-->if (m->create_conf)
							|-->m->create_conf //()
				
					|-->ngx_conf_parse//
				
					|-->for (i = 0; cf->cycle->modules[i]; i++)
						|-->if (cf->cycle->modules[i]->type != NGX_EVENT_MODULE)
							|-->continue
				
						|-->m = cf->cycle->modules[i]->ctx
						|-->if (m->init_conf)
							|-->m->init_conf //(ngx_event.c)
		
		
